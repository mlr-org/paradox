[{"path":"https://paradox.mlr-org.com/articles/indepth.html","id":"parameters-using-paradox","dir":"Articles","previous_headings":"","what":"Parameters (using paradox)","title":"In Depth Tutorial","text":"paradox package offers language description parameter spaces, well tools useful operations parameter spaces. parameter space often useful describing: set sensible input values R function set possible values slots configuration object can take search space optimization process tools provided paradox therefore relate : Parameter checking: Verifying set parameters satisfies conditions parameter space Parameter sampling: Generating parameter values lie parameter space systematic exploration program behavior depending parameters paradox , nature, auxiliary package derives usefulness packages make use . heavily utilized mlr-org packages mlr3, mlr3pipelines, mlr3tuning miesmuschel.","code":""},{"path":"https://paradox.mlr-org.com/articles/indepth.html","id":"reference-based-objects","dir":"Articles","previous_headings":"Parameters (using paradox)","what":"Reference Based Objects","title":"In Depth Tutorial","text":"paradox spiritual successor ParamHelpers package written scratch. important consequence objects created paradox “reference-based”, unlike objects R. change made ParamSet object, example changing $values field, variables point ParamSet contain changed object. create independent copy ParamSet, $clone(deep = TRUE) method needs used:","code":"library(\"paradox\")  ps1 = ps(a = p_int(init = 1)) ps2 = ps1 ps3 = ps1$clone(deep = TRUE) print(ps1) # the same for ps2 and ps3 #> <ParamSet(1)> #>        id    class lower upper nlevels        default  value #>    <char>   <char> <num> <num>   <num>         <list> <list> #> 1:      a ParamInt  -Inf   Inf     Inf <NoDefault[0]>      1 ps1$values$a = 2 print(ps1) # ps1 value of 'a' was changed #> <ParamSet(1)> #>        id    class lower upper nlevels        default  value #>    <char>   <char> <num> <num>   <num>         <list> <list> #> 1:      a ParamInt  -Inf   Inf     Inf <NoDefault[0]>      2 print(ps2) # contains the same reference as ps1, so also changed #> <ParamSet(1)> #>        id    class lower upper nlevels        default  value #>    <char>   <char> <num> <num>   <num>         <list> <list> #> 1:      a ParamInt  -Inf   Inf     Inf <NoDefault[0]>      2 print(ps3) # is a \"clone\" of the old ps1 with 'a' == 1 #> <ParamSet(1)> #>        id    class lower upper nlevels        default  value #>    <char>   <char> <num> <num>   <num>         <list> <list> #> 1:      a ParamInt  -Inf   Inf     Inf <NoDefault[0]>      1"},{"path":[]},{"path":"https://paradox.mlr-org.com/articles/indepth.html","id":"domain-representing-single-parameters","dir":"Articles","previous_headings":"Parameters (using paradox) > Defining a Parameter Space","what":"Domain Representing Single Parameters","title":"In Depth Tutorial","text":"Parameter spaces made individual parameters, usually can take single atomic value. Consider, example, trying configure rpart package’s rpart.control object. various components (minsplit, cp, …) take single value. components represented Domain objects, constructed calls form p_xxx(): p_int() integer numbers p_dbl() real numbers p_fct() categorical values, similar R factors p_lgl() truth values (TRUE / FALSE), logicals R p_uty() parameters can take value ParamSet represent given set parameters created calling ps() named arguments Domain objects. Domain R objects can principle handled manipulated, changed construction. Every parameter can : default - default value, indicating behaviour something specific value given. init - initial value, set $values ParamSet created. Note default: default used parameter present $values, init value set upon creation. special_vals - list values accepted even conform type tags - Tags can used organize parameters trafo - transformation function applied parameter value sampled. example used Design$transpose() function Design created generate_design_random() similar functions. numeric (p_int() p_dbl()) parameters furthermore allow specification lower upper bound. Meanwhile, p_fct() parameter must given vector levels define possible states parameter can take. p_uty parameter can also custom_check function must return TRUE value acceptable may return character(1) error description otherwise. example defines parE parameter accepts functions. values given constructor accessible ParamSet inspection using $. ParamSet considered immutable, except fields $values, $deps, $tags. Bounds levels changed construction. Instead, new ParamSet constructed. Besides possible values can given constructor, also $class, $nlevels, $is_bounded, $has_default, $storage_type, $is_number $is_categ slots give information parameter. list slots can found ?Param. also possible get information ParamSet data.table calling .data.table().","code":"library(\"paradox\") param_set = ps(   parA = p_lgl(init = FALSE),   parB = p_int(lower = 0, upper = 10, tags = c(\"tag1\", \"tag2\")),   parC = p_dbl(lower = 0, upper = 4, special_vals = list(NULL)),   parD = p_fct(levels = c(\"x\", \"y\", \"z\"), default = \"y\"),   parE = p_uty(custom_check = function(x) checkmate::checkFunction(x)) ) param_set #> <ParamSet(5)> #>        id    class lower upper nlevels        default  value #>    <char>   <char> <num> <num>   <num>         <list> <list> #> 1:   parA ParamLgl    NA    NA       2 <NoDefault[0]>  FALSE #> 2:   parB ParamInt     0    10      11 <NoDefault[0]>        #> 3:   parC ParamDbl     0     4     Inf <NoDefault[0]>        #> 4:   parD ParamFct    NA    NA       3              y        #> 5:   parE ParamUty    NA    NA     Inf <NoDefault[0]> param_set$lower #> parA parB parC parD parE  #>   NA    0    0   NA   NA param_set$parD$levels #> NULL param_set$class #>       parA       parB       parC       parD       parE  #> \"ParamLgl\" \"ParamInt\" \"ParamDbl\" \"ParamFct\" \"ParamUty\" as.data.table(param_set) #>        id    class lower upper      levels nlevels is_bounded special_vals #>    <char>   <char> <num> <num>      <list>   <num>     <lgcl>       <list> #> 1:   parA ParamLgl    NA    NA  TRUE,FALSE       2       TRUE    <list[0]> #> 2:   parB ParamInt     0    10                  11       TRUE    <list[0]> #> 3:   parC ParamDbl     0     4                 Inf       TRUE    <list[1]> #> 4:   parD ParamFct    NA    NA       x,y,z       3       TRUE    <list[0]> #> 5:   parE ParamUty    NA    NA                 Inf      FALSE    <list[0]> #>           default storage_type      tags #>            <list>       <char>    <list> #> 1: <NoDefault[0]>      logical           #> 2: <NoDefault[0]>      integer tag1,tag2 #> 3: <NoDefault[0]>      numeric           #> 4:              y    character           #> 5: <NoDefault[0]>         list"},{"path":"https://paradox.mlr-org.com/articles/indepth.html","id":"type-range-checking","dir":"Articles","previous_headings":"Parameters (using paradox) > Defining a Parameter Space > Domain Representing Single Parameters","what":"Type / Range Checking","title":"In Depth Tutorial","text":"ParamSet object offers possibility check whether value satisfies condition, .e. right type, also falls within range allowed values, using $test(), $check(), $assert() functions. argument must named list values checked respective parameters, possible check subset parameters. test() used within conditional checks returns TRUE FALSE, check() returns error description value conform parameter (thus plays well \"checkmate::assert()\" function). assert() throw error whenever value fit.","code":"param_set$test(list(parA = FALSE, parB = 0)) #> [1] TRUE param_set$test(list(parA = \"FALSE\")) #> [1] FALSE param_set$check(list(parA = \"FALSE\")) #> [1] \"parA: Must be of type 'logical flag', not 'character'\""},{"path":"https://paradox.mlr-org.com/articles/indepth.html","id":"parameter-sets","dir":"Articles","previous_headings":"Parameters (using paradox) > Defining a Parameter Space","what":"Parameter Sets","title":"In Depth Tutorial","text":"ordered collection parameters handled ParamSet. typically created calling ps(), can also initialized using ParamSet$new() function. main difference ps() takes named arguments, whereas ParamSet$new() takes named list. latter makes easier construct ParamSet programmatically, slightly verbose. ParamSets can combined using c() ps_union (latter takes list), $subset() method allows subsetting. functions return new, cloned ParamSet object, modify original ParamSet. ParamSets individual parameters can accessed $subspaces() function. possible get ParamSet data.table using .data.table(). makes easy subset parameters certain conditions aggregate information , using variety methods provided data.table.","code":"ps1 = ParamSet$new(list(x = p_int(), y = p_dbl())) ps2 = ParamSet$new(list(z = p_fct(levels = c(\"a\", \"b\", \"c\")))) ps_all = c(ps1, ps2) print(ps_all) #> <ParamSet(3)> #>        id    class lower upper nlevels        default  value #>    <char>   <char> <num> <num>   <num>         <list> <list> #> 1:      x ParamInt  -Inf   Inf     Inf <NoDefault[0]>        #> 2:      y ParamDbl  -Inf   Inf     Inf <NoDefault[0]>        #> 3:      z ParamFct    NA    NA       3 <NoDefault[0]> ps_all$subset(c(\"x\", \"z\")) #> <ParamSet(2)> #>        id    class lower upper nlevels        default  value #>    <char>   <char> <num> <num>   <num>         <list> <list> #> 1:      x ParamInt  -Inf   Inf     Inf <NoDefault[0]>        #> 2:      z ParamFct    NA    NA       3 <NoDefault[0]> as.data.table(ps_all) #>        id    class lower upper levels nlevels is_bounded special_vals #>    <char>   <char> <num> <num> <list>   <num>     <lgcl>       <list> #> 1:      x ParamInt  -Inf   Inf            Inf      FALSE    <list[0]> #> 2:      y ParamDbl  -Inf   Inf            Inf      FALSE    <list[0]> #> 3:      z ParamFct    NA    NA  a,b,c       3       TRUE    <list[0]> #>           default storage_type   tags #>            <list>       <char> <list> #> 1: <NoDefault[0]>      integer        #> 2: <NoDefault[0]>      numeric        #> 3: <NoDefault[0]>    character"},{"path":"https://paradox.mlr-org.com/articles/indepth.html","id":"values-in-a-paramset","dir":"Articles","previous_headings":"Parameters (using paradox) > Defining a Parameter Space > Parameter Sets","what":"Values in a ParamSet","title":"In Depth Tutorial","text":"Although ParamSet fundamentally represents value space, also slot $values can contain point within space. useful many things define parameter space need similar operations (like parameter checking) can simplified. $values slot contains named list always checked parameter constraints. trying set parameter values, e.g. mlr3 Learners, $values slot $param_set needs used. parameter constraints automatically checked:","code":"ps1$values = list(x = 1, y = 1.5) ps1$values$y = 2.5 print(ps1$values) #> $x #> [1] 1 #>  #> $y #> [1] 2.5 ps1$values$x = 1.5 #> Error in self$assert(xs): Assertion on 'xs' failed: x: Must be of type 'single integerish value', not 'double'."},{"path":"https://paradox.mlr-org.com/articles/indepth.html","id":"dependencies","dir":"Articles","previous_headings":"Parameters (using paradox) > Defining a Parameter Space > Parameter Sets","what":"Dependencies","title":"In Depth Tutorial","text":"often case certain parameters irrelevant given depending values parameters. example parameter switches certain algorithm feature (example regularization) , combined another parameter controls behavior feature (e.g. regularization parameter). second parameter said depend first parameter value TRUE. dependency can added using $add_dep method, takes ids “depender” “dependee” parameters well Condition object. Condition object represents check performed “dependee”. Currently can created using CondEqual() CondAnyOf(). Multiple dependencies can added, parameters depend others can depended , long cyclic dependencies introduced. consequence dependencies twofold: one, $check(), $test() $assert() tests accept presence parameter dependency met, check_strict argument given TRUE. Furthermore, sampling creating grid designs ParamSet, dependencies respected. easiest way set dependencies give depends argument Domain constructor. following example makes parameter D depend parameter FALSE, parameter B depend parameter D one \"x\" \"y\". introduces implicit dependency B FALSE well, D take value TRUE. Note depends argument limited operators == %%, D = p_fct(..., depends = !) work. Internally, dependencies represented data.table, can accessed listed $deps slot. data.table can even mutated, e.g. remove dependencies. sanity checks done $deps slot changed way. Therefore advised cautious.","code":"p = ps(   A = p_lgl(init = FALSE),   B = p_int(lower = 0, upper = 10, depends = D %in% c(\"x\", \"y\")),   C = p_dbl(lower = 0, upper = 4),   D = p_fct(levels = c(\"x\", \"y\", \"z\"), depends = A == FALSE) ) p$check(list(A = FALSE, D = \"x\", B = 1), check_strict = TRUE)  # OK: all dependencies met #> [1] TRUE p$check(list(A = FALSE, D = \"z\", B = 1), check_strict = TRUE)  # B's dependency is not met #> [1] \"B: can only be set if the following condition is met 'D %in% {x, y}'. Instead the current parameter value is: D == z\" p$check(list(A = FALSE, B = 1), check_strict = TRUE)           # B's dependency is not met #> [1] \"B: can only be set if the following condition is met 'D %in% {x, y}'. Instead the parameter value for 'D' is not set at all. Try setting 'D' to a value that satisfies the condition\" p$check(list(A = FALSE, D = \"z\"), check_strict = TRUE)         # OK: B is absent #> [1] TRUE p$check(list(A = TRUE), check_strict = TRUE)                   # OK: neither B nor D present #> [1] TRUE p$check(list(A = TRUE, D = \"x\", B = 1), check_strict = TRUE)   # D's dependency is not met #> [1] \"D: can only be set if the following condition is met 'A == FALSE'. Instead the current parameter value is: A == TRUE\" p$check(list(A = TRUE, B = 1), check_strict = TRUE)            # B's dependency is not met #> [1] \"B: can only be set if the following condition is met 'D %in% {x, y}'. Instead the parameter value for 'D' is not set at all. Try setting 'D' to a value that satisfies the condition\" p$deps #> Index: <id> #>        id     on                  cond #>    <char> <char>                <list> #> 1:      B      D <Condition:CondAnyOf> #> 2:      D      A <Condition:CondEqual>"},{"path":"https://paradox.mlr-org.com/articles/indepth.html","id":"vector-parameters","dir":"Articles","previous_headings":"Parameters (using paradox) > Defining a Parameter Space","what":"Vector Parameters","title":"In Depth Tutorial","text":"Unlike old ParamHelpers package, vectorial parameters paradox. Instead, now possible create multiple copies single parameter using ps_replicate function. creates ParamSet consisting multiple copies parameter, can (optionally) added another ParamSet. also possible use ParamUty accept vectorial parameters, also works parameters variable length. ParamSet containing ParamUty can used parameter checking, sampling. sample values method needs vectorial parameter, advised use $extra_trafo transformation function creates vector atomic values. Assembling vector repeated parameters aided parameter’s $tags: Parameters generated pr_replicate() command can tagged belonging group repeated parameters.","code":"ps2d = ps_replicate(ps(x = p_dbl(lower = 0, upper = 1)), 2) print(ps2d) #> <ParamSet(2)> #>        id    class lower upper nlevels        default  value #>    <char>   <char> <num> <num>   <num>         <list> <list> #> 1: rep1.x ParamDbl     0     1     Inf <NoDefault[0]>        #> 2: rep2.x ParamDbl     0     1     Inf <NoDefault[0]> ps2d = ps_replicate(ps(x = p_dbl(0, 1), y = p_int(0, 10)), 2, tag_params = TRUE) ps2d$values = list(rep1.x = 0.2, rep2.x = 0.4, rep1.y = 3, rep2.y = 4) ps2d$tags #> $rep1.x #> [1] \"param_x\" #>  #> $rep1.y #> [1] \"param_y\" #>  #> $rep2.x #> [1] \"param_x\" #>  #> $rep2.y #> [1] \"param_y\" ps2d$get_values(tags = \"param_x\") #> $rep1.x #> [1] 0.2 #>  #> $rep2.x #> [1] 0.4"},{"path":"https://paradox.mlr-org.com/articles/indepth.html","id":"parameter-sampling","dir":"Articles","previous_headings":"Parameters (using paradox)","what":"Parameter Sampling","title":"In Depth Tutorial","text":"often useful list possible parameter values can systematically iterated , example find parameter values algorithm performs particularly well (tuning). paradox offers variety functions allow creating evenly-spaced parameter values “grid” design well random sampling. latter case, possible influence sampling distribution less fine detail. point always keep mind sampling numerical factorial parameters bounded can sampled , .e. ParamUty. Furthermore, samplers p_int() p_dbl() must finite lower upper bounds.","code":""},{"path":"https://paradox.mlr-org.com/articles/indepth.html","id":"parameter-designs","dir":"Articles","previous_headings":"Parameters (using paradox) > Parameter Sampling","what":"Parameter Designs","title":"In Depth Tutorial","text":"Functions sample parameter space fundamentally return object Design class. objects contain sampled data data.table $data slot, also offer conversion list parameter-values using $transpose() function.","code":""},{"path":"https://paradox.mlr-org.com/articles/indepth.html","id":"grid-design","dir":"Articles","previous_headings":"Parameters (using paradox) > Parameter Sampling","what":"Grid Design","title":"In Depth Tutorial","text":"generate_design_grid() function used create grid designs contain combinations parameter values: possible values ParamLgl ParamFct, values given resolution ParamInt ParamDbl. resolution can given numeric parameters, specific named parameters param_resolutions parameter.","code":"ps_small = ps(A = p_dbl(0, 1), B = p_dbl(0, 1)) design = generate_design_grid(ps_small, 2) print(design) #> <Design> with 4 rows: #>        A     B #>    <num> <num> #> 1:     0     0 #> 2:     0     1 #> 3:     1     0 #> 4:     1     1 generate_design_grid(ps_small, param_resolutions = c(A = 3, B = 2)) #> <Design> with 6 rows: #>        A     B #>    <num> <num> #> 1:   0.0     0 #> 2:   0.0     1 #> 3:   0.5     0 #> 4:   0.5     1 #> 5:   1.0     0 #> 6:   1.0     1"},{"path":"https://paradox.mlr-org.com/articles/indepth.html","id":"random-sampling","dir":"Articles","previous_headings":"Parameters (using paradox) > Parameter Sampling","what":"Random Sampling","title":"In Depth Tutorial","text":"paradox offers different methods random sampling, vary degree can configured. easiest way get uniformly random sample parameters generate_design_random(). also possible create “latin hypercube” sampled parameter values using generate_design_lhs(), utilizes lhs package. LHS-sampling creates low-discrepancy sampled values cover parameter space evenly purely random values. generate_design_sobol() can used sample using Sobol sequence.","code":"pvrand = generate_design_random(ps_small, 500) pvlhs = generate_design_lhs(ps_small, 500) pvsobol = generate_design_sobol(ps_small, 500)"},{"path":"https://paradox.mlr-org.com/articles/indepth.html","id":"generalized-sampling-the-sampler-class","dir":"Articles","previous_headings":"Parameters (using paradox) > Parameter Sampling","what":"Generalized Sampling: The Sampler Class","title":"In Depth Tutorial","text":"may sometimes desirable configure parameter sampling detail. paradox uses Sampler abstract base class sampling, many different sub-classes can parameterized combined control sampling process. even possible create sub-classes Sampler class (subclasses) even possibilities. Every Sampler object sample() function, takes one argument, number instances sample, returns Design object.","code":""},{"path":"https://paradox.mlr-org.com/articles/indepth.html","id":"d-samplers","dir":"Articles","previous_headings":"Parameters (using paradox) > Parameter Sampling > Generalized Sampling: The Sampler Class","what":"1D-Samplers","title":"In Depth Tutorial","text":"variety samplers sample values single parameter. Sampler1DUnif (uniform sampling), Sampler1DCateg (sampling categorical parameters), Sampler1DNormal (normally distributed sampling, truncated parameter bounds), Sampler1DRfun (arbitrary 1D sampling, given random-function). initialized one-dimensional ParamSet, can used sample values.","code":"sampA = Sampler1DCateg$new(ps(x = p_fct(letters))) sampA$sample(5) #> <Design> with 5 rows: #>         x #>    <char> #> 1:      f #> 2:      k #> 3:      e #> 4:      g #> 5:      f"},{"path":"https://paradox.mlr-org.com/articles/indepth.html","id":"hierarchical-sampler","dir":"Articles","previous_headings":"Parameters (using paradox) > Parameter Sampling > Generalized Sampling: The Sampler Class","what":"Hierarchical Sampler","title":"In Depth Tutorial","text":"SamplerHierarchical sampler auxiliary sampler combines many 1D-Samplers get combined distribution. name “hierarchical” implies able respect parameter dependencies. suggests parameters get sampled dependencies met. following example shows works: Int parameter B depends Lgl parameter TRUE. sampled TRUE half cases, case B takes value 0 10. cases FALSE, B set NA.","code":"p = ps(   A = p_lgl(),   B = p_int(0, 10, depends = A == TRUE) )  p_subspaces = p$subspaces()  sampH = SamplerHierarchical$new(p,   list(Sampler1DCateg$new(p_subspaces$A),     Sampler1DUnif$new(p_subspaces$B)) ) sampled = sampH$sample(1000) head(sampled$data) #>         A     B #>    <lgcl> <int> #> 1:  FALSE    NA #> 2:  FALSE    NA #> 3:   TRUE     7 #> 4:   TRUE    10 #> 5:   TRUE     2 #> 6:  FALSE    NA table(sampled$data[, c(\"A\", \"B\")], useNA = \"ifany\") #>        B #> A         0   1   2   3   4   5   6   7   8   9  10 <NA> #>   FALSE   0   0   0   0   0   0   0   0   0   0   0  492 #>   TRUE   50  45  57  49  49  38  39  47  44  42  48    0"},{"path":"https://paradox.mlr-org.com/articles/indepth.html","id":"joint-sampler","dir":"Articles","previous_headings":"Parameters (using paradox) > Parameter Sampling > Generalized Sampling: The Sampler Class","what":"Joint Sampler","title":"In Depth Tutorial","text":"Another way combining samplers SamplerJointIndep. SamplerJointIndep also makes possible combine Samplers 1D. However, SamplerJointIndep currently can handle ParamSets dependencies.","code":"sampJ = SamplerJointIndep$new(   list(Sampler1DUnif$new(ps(x = p_dbl(0, 1))),     Sampler1DUnif$new(ps(y = p_dbl(0, 1)))) ) sampJ$sample(5) #> <Design> with 5 rows: #>            x           y #>        <num>       <num> #> 1: 0.4889776 0.454001049 #> 2: 0.2828764 0.165267821 #> 3: 0.8167114 0.959529563 #> 4: 0.9697799 0.003741143 #> 5: 0.2319606 0.646213624"},{"path":"https://paradox.mlr-org.com/articles/indepth.html","id":"samplerunif","dir":"Articles","previous_headings":"Parameters (using paradox) > Parameter Sampling > Generalized Sampling: The Sampler Class","what":"SamplerUnif","title":"In Depth Tutorial","text":"Sampler used generate_design_random() SamplerUnif sampler, corresponds HierarchicalSampler Sampler1DUnif parameters.","code":""},{"path":"https://paradox.mlr-org.com/articles/indepth.html","id":"parameter-transformation","dir":"Articles","previous_headings":"Parameters (using paradox)","what":"Parameter Transformation","title":"In Depth Tutorial","text":"different Samplers allow wide specification parameter distributions, cases simplest way getting desired distribution sample parameters simple distribution (uniform distribution) transform . can done constructing Domain trafo argument, assigning function $extra_trafo field ParamSet. latter can also done passing .extra_trafo argument ps() shorthand constructor. trafo function Domain called single parameter, value transformed. can operate dimension single parameter. $extra_trafo function called two parameters: list parameter values transformed x. Unlike Domain’s trafo, $extra_trafo handles whole parameter set can even model “interactions” parameters. ParamSet param_set $extra_trafo function must return list transformed parameter values. transformation performed calling $transpose function Design object returned Sampler trafo ParamSet TRUE (default). following, example, creates parameter exponentially distributed: Compare $transpose() without transformation: Another way get tihs effect, using $extra_trafo, : However, trafo way recommended transforming parameters independently. $extra_trafo useful transforming parameters interact way, new parameters generated.","code":"psexp = ps(par = p_dbl(0, 1, trafo = function(x) -log(x)))  design = generate_design_random(psexp, 3) print(design)  # not transformed: between 0 and 1 #> <Design> with 3 rows: #>          par #>        <num> #> 1: 0.9824873 #> 2: 0.4098267 #> 3: 0.7395942 design$transpose()  # trafo is TRUE #> [[1]] #> [[1]]$par #> [1] 0.01766784 #>  #>  #> [[2]] #> [[2]]$par #> [1] 0.892021 #>  #>  #> [[3]] #> [[3]]$par #> [1] 0.3016537 design$transpose(trafo = FALSE) #> [[1]] #> [[1]]$par #> [1] 0.9824873 #>  #>  #> [[2]] #> [[2]]$par #> [1] 0.4098267 #>  #>  #> [[3]] #> [[3]]$par #> [1] 0.7395942 psexp = ps(par = p_dbl(0, 1)) psexp$extra_trafo = function(x, param_set) {   x$par = -log(x$par)   x }"},{"path":"https://paradox.mlr-org.com/articles/indepth.html","id":"transformation-between-types","dir":"Articles","previous_headings":"Parameters (using paradox) > Parameter Transformation","what":"Transformation between Types","title":"In Depth Tutorial","text":"Usually design created one ParamSet used configure objects ParamSet defines values take. ParamSets can used random sampling, however, restricted ways: must finite bounds, may contain “untyped” (ParamUty) parameters. $trafo provides glue situations. relatively little constraint trafo function’s return value, possible return values different bounds even types original ParamSet. even possible remove parameters add new ones. Suppose, example, certain method requires function parameter. Let’s say function summarizes data certain way. user can pass functions like median() mean(), also pass quantiles something completely different. method probably use following ParamSet: one wanted sample method, using one four functions, way : Note Design contains column “fun” character column. get single value function, $transpose function used. can now check fits requirements set methodPS, fun fact function: p_fct() shortcut kind transformation, character transformed specific set (typically non-scalar) values. levels argument given named list (named non-character vector), constructs Domain trafo automatically. way perform therefore : Imagine now different kind parametrization function desired: user wants give function selects certain quantile, quantile set parameter. case $transpose function generate function different way. interpretability, parameter called “quantile” transformation, “fun” parameter generated fly. therefore use extra_trafo , given function ps() call. Design now contains column “quantile” used $transpose function create fun parameter. also check fits requirement set methodPS, function.","code":"methodPS = ps(fun = p_uty(custom_check = function(x) checkmate::checkFunction(x, nargs = 1)))  print(methodPS) #> <ParamSet(1)> #>        id    class lower upper nlevels        default  value #>    <char>   <char> <num> <num>   <num>         <list> <list> #> 1:    fun ParamUty    NA    NA     Inf <NoDefault[0]> samplingPS = ps(   fun = p_fct(c(\"mean\", \"median\", \"min\", \"max\"),     trafo = function(x) get(x, mode = \"function\")) ) design = generate_design_random(samplingPS, 2) print(design) #> <Design> with 2 rows: #>       fun #>    <char> #> 1:    min #> 2: median xvals = design$transpose() print(xvals[[1]]) #> $fun #> function (..., na.rm = FALSE)  .Primitive(\"min\") methodPS$check(xvals[[1]]) #> [1] TRUE xvals[[1]]$fun(1:10) #> [1] 1 samplingPS = ps(   fun = p_fct(list(\"mean\" = mean, \"median\" = median, \"min\" = min, \"max\" = max)) )  generate_design_random(samplingPS, 1)$transpose() #> [[1]] #> [[1]]$fun #> function (x, ...)  #> UseMethod(\"mean\") #> <bytecode: 0x55ed78fe2dd8> #> <environment: namespace:base> samplingPS2 = ps(quantile = p_dbl(0, 1),   .extra_trafo = function(x, param_set) {     # x$quantile is a `numeric(1)` between 0 and 1.     # We want to turn it into a function!     list(fun = function(input) quantile(input, x$quantile))   } ) design = generate_design_random(samplingPS2, 2) print(design) #> <Design> with 2 rows: #>     quantile #>        <num> #> 1: 0.6744397 #> 2: 0.9373676 xvals = design$transpose() print(xvals[[1]]) #> $fun #> function(input) quantile(input, x$quantile) #> <environment: 0x55ed7c6d0068> methodPS$check(xvals[[1]]) #> [1] TRUE xvals[[1]]$fun(1:10) #> 67.44397%  #>  7.069958"},{"path":"https://paradox.mlr-org.com/articles/indepth.html","id":"defining-a-tuning-spaces","dir":"Articles","previous_headings":"Parameters (using paradox)","what":"Defining a Tuning Spaces","title":"In Depth Tutorial","text":"running optimization, important inform tuning algorithm hyperparameters valid. names, types, valid ranges hyperparameter important. information communicated objects class ParamSet, defined paradox. Note, ParamSet objects exist two contexts. First, ParamSet-objects used define space valid parameter settings learner (objects). Second, used define search space tuning. mainly interested latter. example can consider minsplit parameter mlr_learners_classif.rpart\", \"classif.rpart Learner. ParamSet associated learner lower upper bound. However, tuning value, lower upper bound must given tuning search spaces need bounded. Learner PipeOp objects, typically “unbounded” ParamSets used. , however, mainly focus creating “bounded” ParamSets can used tuning.","code":""},{"path":"https://paradox.mlr-org.com/articles/indepth.html","id":"creating-paramsets","dir":"Articles","previous_headings":"Parameters (using paradox) > Defining a Tuning Spaces","what":"Creating ParamSets","title":"In Depth Tutorial","text":"empty \"ParamSet – yet useful – can constructed using just \"ps\" call: ps takes named Domain arguments turned parameters. possible search space \"classif.svm\" learner example : five domain constructors produce parameters given ps: domain constructors take following arguments: lower, upper: lower upper bound numerical parameters (p_dbl p_int). need given get bounded parameter spaces valid tuning. levels: Allowed categorical values p_fct parameters. Required argument p_fct. See details parameter. trafo: transformation function, see . depends: dependencies, see . tags: information parameter, used example hyperband tuner. init: . used tuning search spaces. default: Value corresponding default behavior parameter given. used tuning search spaces. special_vals: Valid values besides normally accepted values parameter. used tuning search spaces. custom_check: Function checks whether value given p_uty valid. used tuning search spaces. lower upper parameters always first second position respectively, except p_fct levels first position. preferred omit labels (ex: upper = 0.1 becomes just 0.1). way defining ParamSet concise equivalent definition . Preferred:","code":"search_space = ps() print(search_space) #> <ParamSet(0)> #> Empty. search_space = ps(   cost = p_dbl(lower = 0.1, upper = 10),   kernel = p_fct(levels = c(\"polynomial\", \"radial\")) ) print(search_space) #> <ParamSet(2)> #>        id    class lower upper nlevels        default  value #>    <char>   <char> <num> <num>   <num>         <list> <list> #> 1:   cost ParamDbl   0.1    10     Inf <NoDefault[0]>        #> 2: kernel ParamFct    NA    NA       2 <NoDefault[0]> search_space = ps(cost = p_dbl(0.1, 10), kernel = p_fct(c(\"polynomial\", \"radial\")))"},{"path":"https://paradox.mlr-org.com/articles/indepth.html","id":"transformations-trafo","dir":"Articles","previous_headings":"Parameters (using paradox) > Defining a Tuning Spaces","what":"Transformations (trafo)","title":"In Depth Tutorial","text":"can use paradox function generate_design_grid look values evaluated grid search. (using rbindlist() result $transpose() list harder read. didn’t use $transpose(), hand, transformations investigate applied.) generate_design_grid(search_space, 3), search_space ParamSet argument 3 specified resolution parameter space. resolution categorical parameters ignored; parameters always produce grid valid levels. numerical parameters endpoints params always included grid, 3 levels kernel instead 2 9 rows, resolution 4 example 8 rows resulting table. notice cost parameter taken linear scale. assume, however, difference cost 0.1 1 similar effect difference 1 10. Therefore makes sense tune logarithmic scale. done using transformation (trafo). function applied parameter sampled tuner. can tune cost logarithmic scale sampling linear scale [-1, 1] computing 10^x value. even possible attach another transformation ParamSet whole gets executed individual parameter’s transformations performed. given .extra_trafo argument function parameters x param_set takes list parameter values x returns modified list. transformation can access parameter values evaluation modify interactions. even possible add remove parameters. (following bit silly example.) available types search space parameters limited: continuous, integer, discrete, logical scalars. many machine learning algorithms, however, take parameters types, example vectors functions. can defined search space ParamSet, often given p_uty() Learner’s ParamSet. trying tune hyperparameters, necessary perform Transformation changes type parameter. example class.weights parameter Support Vector Machine (SVM), takes named vector class weights one entry target class. trafo tune class.weights tsk(\"spam\") dataset : (omitting rbindlist() example breaks vector valued return elements.)","code":"library(\"data.table\") rbindlist(generate_design_grid(search_space, 3)$transpose()) #>     cost     kernel #>    <num>     <char> #> 1:  0.10 polynomial #> 2:  0.10     radial #> 3:  5.05 polynomial #> 4:  5.05     radial #> 5: 10.00 polynomial #> 6: 10.00     radial search_space = ps(   cost = p_dbl(-1, 1, trafo = function(x) 10^x),   kernel = p_fct(c(\"polynomial\", \"radial\")) ) rbindlist(generate_design_grid(search_space, 3)$transpose()) #>     cost     kernel #>    <num>     <char> #> 1:   0.1 polynomial #> 2:   0.1     radial #> 3:   1.0 polynomial #> 4:   1.0     radial #> 5:  10.0 polynomial #> 6:  10.0     radial search_space = ps(   cost = p_dbl(-1, 1, trafo = function(x) 10^x),   kernel = p_fct(c(\"polynomial\", \"radial\")),   .extra_trafo = function(x, param_set) {     if (x$kernel == \"polynomial\") {       x$cost = x$cost * 2     }     x   } ) rbindlist(generate_design_grid(search_space, 3)$transpose()) #>     cost     kernel #>    <num>     <char> #> 1:   0.2 polynomial #> 2:   0.1     radial #> 3:   2.0 polynomial #> 4:   1.0     radial #> 5:  20.0 polynomial #> 6:  10.0     radial search_space = ps(   class.weights = p_dbl(0.1, 0.9, trafo = function(x) c(spam = x, nonspam = 1 - x)) ) generate_design_grid(search_space, 3)$transpose() #> [[1]] #> [[1]]$class.weights #>    spam nonspam  #>     0.1     0.9  #>  #>  #> [[2]] #> [[2]]$class.weights #>    spam nonspam  #>     0.5     0.5  #>  #>  #> [[3]] #> [[3]]$class.weights #>    spam nonspam  #>     0.9     0.1"},{"path":"https://paradox.mlr-org.com/articles/indepth.html","id":"automatic-factor-level-transformation","dir":"Articles","previous_headings":"Parameters (using paradox)","what":"Automatic Factor Level Transformation","title":"In Depth Tutorial","text":"common use-case necessity specify list values tried (sampled ). may case hyperparameter accepts function objects values certain list functions tried. may choice special numeric values tried. , p_fct constructor’s level argument may value character vector, something else. , example, values 0.1, 3, 10 tried cost parameter, even random search, following search space achieve : equivalent following: Note: Though resolution 3 , case doesn’t matter cost kernel factors (resolution categorical variables ignored, parameters always produce grid valid levels). may seem silly, makes sense considering factorial tuning parameters always character values: aware results “unordered” hyperparameter, however. Tuning algorithms make use ordering information parameters, like genetic algorithms model based optimization, perform worse done. algorithms, may make sense define p_dbl p_int fitting trafo. class.weights case can also implemented like , candidates class.weights vectors tried. Note levels argument p_fct must named easy way .character() create names:","code":"search_space = ps(   cost = p_fct(c(0.1, 3, 10)),   kernel = p_fct(c(\"polynomial\", \"radial\")) ) rbindlist(generate_design_grid(search_space, 3)$transpose()) #>     cost     kernel #>    <num>     <char> #> 1:   0.1 polynomial #> 2:   0.1     radial #> 3:   3.0 polynomial #> 4:   3.0     radial #> 5:  10.0 polynomial #> 6:  10.0     radial search_space = ps(   cost = p_fct(c(\"0.1\", \"3\", \"10\"),     trafo = function(x) list(`0.1` = 0.1, `3` = 3, `10` = 10)[[x]]),   kernel = p_fct(c(\"polynomial\", \"radial\")) ) rbindlist(generate_design_grid(search_space, 3)$transpose()) #>     cost     kernel #>    <num>     <char> #> 1:   0.1 polynomial #> 2:   0.1     radial #> 3:   3.0 polynomial #> 4:   3.0     radial #> 5:  10.0 polynomial #> 6:  10.0     radial search_space = ps(   cost = p_fct(c(0.1, 3, 10)),   kernel = p_fct(c(\"polynomial\", \"radial\")) ) typeof(search_space$params$cost$levels) #> [1] \"NULL\" search_space = ps(   class.weights = p_fct(     list(       candidate_a = c(spam = 0.5, nonspam = 0.5),       candidate_b = c(spam = 0.3, nonspam = 0.7)     )   ) ) generate_design_grid(search_space)$transpose() #> [[1]] #> [[1]]$class.weights #>    spam nonspam  #>     0.5     0.5  #>  #>  #> [[2]] #> [[2]]$class.weights #>    spam nonspam  #>     0.3     0.7"},{"path":"https://paradox.mlr-org.com/articles/indepth.html","id":"parameter-dependencies-depends","dir":"Articles","previous_headings":"Parameters (using paradox) > Automatic Factor Level Transformation","what":"Parameter Dependencies (depends)","title":"In Depth Tutorial","text":"parameters relevant another parameter certain value, one several values. Support Vector Machine (SVM), example, degree parameter valid kernel \"polynomial\". can specified using depends argument. expression must involve parameters form <param> == <scalar>, <param> %% <vector>, multiple chained &&. tune degree parameter, one need following:","code":"search_space = ps(   cost = p_dbl(-1, 1, trafo = function(x) 10^x),   kernel = p_fct(c(\"polynomial\", \"radial\")),   degree = p_int(1, 3, depends = kernel == \"polynomial\") ) rbindlist(generate_design_grid(search_space, 3)$transpose(), fill = TRUE) #>      cost     kernel degree #>     <num>     <char>  <int> #>  1:   0.1 polynomial      1 #>  2:   0.1 polynomial      2 #>  3:   0.1 polynomial      3 #>  4:   0.1     radial     NA #>  5:   1.0 polynomial      1 #>  6:   1.0 polynomial      2 #>  7:   1.0 polynomial      3 #>  8:   1.0     radial     NA #>  9:  10.0 polynomial      1 #> 10:  10.0 polynomial      2 #> 11:  10.0 polynomial      3 #> 12:  10.0     radial     NA"},{"path":"https://paradox.mlr-org.com/articles/indepth.html","id":"creating-tuning-paramsets-from-other-paramsets","dir":"Articles","previous_headings":"Parameters (using paradox) > Automatic Factor Level Transformation","what":"Creating Tuning ParamSets from other ParamSets","title":"In Depth Tutorial","text":"define tuning ParamSet Learner already parameter set information may seem unnecessarily tedious, indeed way create tuning ParamSets Learner’s ParamSet, making use much information already available. done setting values Learner’s ParamSet -called TuneTokens, constructed to_tune call. can done way hyperparameters set specific values. can understood hyperparameters tagged later tuning. resulting ParamSet used tuning can retrieved using $search_space() method. possible omit lower , can inferred lower bound degree parameter . parameters, already bounded, possible give bounds , ranges already bounded. example logical shrinking hyperparameter: \"to_tune\" can also constructed Domain object, .e. something constructed p_*** call. way possible tune continuous parameters discrete values, give trafos dependencies. One , example, tune cost three given special values, introduce dependency shrinking . Notice short form to_tune(<levels>) short form to_tune(p_fct(<levels>)). introducing dependency, need use degree value implicit trafo, name .character() respective value, \"val2\"! search_space() picks dependencies underlying ParamSet automatically. kernel tuned, degree automatically gets dependency , without us specify . (reset cost shrinking NULL sake clarity generated output.) even possible define whole ParamSets get tuned single parameter. may especially useful vector hyperparameters searched along multiple dimensions. ParamSet must, however, .extra_trafo returns list single element, corresponds single hyperparameter tuned. Suppose class.weights hyperparameter tuned along two dimensions:","code":"library(\"mlr3learners\") learner = lrn(\"classif.svm\") learner$param_set$values$kernel = \"polynomial\" # for example learner$param_set$values$degree = to_tune(lower = 1, upper = 3)  print(learner$param_set$search_space())  rbindlist(generate_design_grid(   learner$param_set$search_space(), 3)$transpose() ) learner$param_set$values$shrinking = to_tune()  print(learner$param_set$search_space())  rbindlist(generate_design_grid(   learner$param_set$search_space(), 3)$transpose() ) learner$param_set$values$type = \"C-classification\" # needs to be set because of a bug in paradox learner$param_set$values$cost = to_tune(c(val1 = 0.3, val2 = 0.7)) learner$param_set$values$shrinking = to_tune(p_lgl(depends = cost == \"val2\"))  print(learner$param_set$search_space())  rbindlist(generate_design_grid(learner$param_set$search_space(), 3)$transpose(), fill = TRUE) learner$param_set$values$cost = NULL learner$param_set$values$shrinking = NULL learner$param_set$values$kernel = to_tune(c(\"polynomial\", \"radial\"))  print(learner$param_set$search_space())  rbindlist(generate_design_grid(learner$param_set$search_space(), 3)$transpose(), fill = TRUE) learner$param_set$values$class.weights = to_tune(   ps(spam = p_dbl(0.1, 0.9), nonspam = p_dbl(0.1, 0.9),     .extra_trafo = function(x, param_set) list(c(spam = x$spam, nonspam = x$nonspam)) )) head(generate_design_grid(learner$param_set$search_space(), 3)$transpose(), 3)"},{"path":"https://paradox.mlr-org.com/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Michel Lang. Author. Bernd Bischl. Author. Jakob Richter. Author. Xudong Sun. Author. Martin Binder. Author, maintainer. Marc Becker. Contributor.","code":""},{"path":"https://paradox.mlr-org.com/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lang M, Bischl B, Richter J, Sun X, Binder M (2024). paradox: Define Work Parameter Spaces Complex Algorithms. R package version 1.0.0,  https://github.com/mlr-org/paradox, https://paradox.mlr-org.com.","code":"@Manual{,   title = {paradox: Define and Work with Parameter Spaces for Complex Algorithms},   author = {Michel Lang and Bernd Bischl and Jakob Richter and Xudong Sun and Martin Binder},   year = {2024},   note = {R package version 1.0.0,  https://github.com/mlr-org/paradox},   url = {https://paradox.mlr-org.com}, }"},{"path":"https://paradox.mlr-org.com/index.html","id":"paradox","dir":"","previous_headings":"","what":"Define and Work with Parameter Spaces for Complex Algorithms","title":"Define and Work with Parameter Spaces for Complex Algorithms","text":"Package website: release | dev Universal Parameter Space Description Tools.","code":""},{"path":"https://paradox.mlr-org.com/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Define and Work with Parameter Spaces for Complex Algorithms","text":"","code":"remotes::install_github(\"mlr-org/paradox\")"},{"path":"https://paradox.mlr-org.com/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Define and Work with Parameter Spaces for Complex Algorithms","text":"Create simple ParamSet using supported Parameter Types: integer numbers (\"int\") real-valued numbers (\"dbl\") truth values TRUE FALSE (\"lgl\") categorical values set possible strings (\"fct\") types possible using transformations. Draw random samples / create random design: Generate LHS Design: Generate Grid Design: Properties parameters within ParamSet:","code":"pset = ps(   z = p_int(lower = 1, upper = 3),   x = p_dbl(lower = -10, upper = 10),   flag = p_lgl(),   methods = p_fct(c(\"a\",\"b\",\"c\")) ) generate_design_random(pset, 3) #> <Design> with 3 rows: #>    z         x  flag methods #> 1: 1  7.660348 FALSE       b #> 2: 3  8.809346 FALSE       c #> 3: 2 -9.088870 FALSE       b requireNamespace(\"lhs\") #> Loading required namespace: lhs generate_design_lhs(pset, 3) #> <Design> with 3 rows: #>    z         x  flag methods #> 1: 1 -3.984673  TRUE       b #> 2: 2  7.938035 FALSE       a #> 3: 3  1.969783  TRUE       c generate_design_grid(pset, resolution = 2) #> <Design> with 24 rows: #>     z   x  flag methods #>  1: 1 -10  TRUE       a #>  2: 1 -10  TRUE       b #>  3: 1 -10  TRUE       c #>  4: 1 -10 FALSE       a #>  5: 1 -10 FALSE       b #>  6: 1 -10 FALSE       c #>  7: 1  10  TRUE       a #>  [ reached getOption(\"max.print\") -- omitted 18 rows ] pset$ids() #> [1] \"z\"       \"x\"       \"flag\"    \"methods\" pset$levels #> $z #> NULL #>  #> $x #> NULL #>  #> $flag #> [1]  TRUE FALSE #>  #> $methods #> [1] \"a\" \"b\" \"c\" pset$nlevels #>       z       x    flag methods  #>       3     Inf       2       3 pset$is_number #>       z       x    flag methods  #>    TRUE    TRUE   FALSE   FALSE pset$lower #>       z       x    flag methods  #>       1     -10      NA      NA pset$upper #>       z       x    flag methods  #>       3      10      NA      NA"},{"path":"https://paradox.mlr-org.com/index.html","id":"parameter-checks","dir":"","previous_headings":"Usage","what":"Parameter Checks","title":"Define and Work with Parameter Spaces for Complex Algorithms","text":"Check parameter satisfies conditions ParamSet, using $test() (returns FALSE mismatch), $check() (returns error description mismatch), $assert() (throws error mismatch):","code":"pset$test(list(z = 1, x = 1)) #> [1] TRUE pset$test(list(z = -1, x = 1)) #> [1] FALSE pset$check(list(z = -1, x = 1)) #> [1] \"z: Element 1 is not >= 0.5\" pset$assert(list(z = -1, x = 1)) #> Error in pset$assert(list(z = -1, x = 1)): Assertion on 'list(z = -1, x = 1)' failed: z: Element 1 is not >= 0.5."},{"path":"https://paradox.mlr-org.com/index.html","id":"transformations","dir":"","previous_headings":"Usage","what":"Transformations","title":"Define and Work with Parameter Spaces for Complex Algorithms","text":"Transformations functions fixed signature. x named list parameter values param_set ParamSet used create design Transformations can used change distributions sampled parameters. example, sample values 2−3 23 log2-uniform distribution, one can sample uniformly -3 3 exponentiate random value inside transformation. Alternatively, logscale = TRUE can set; case, lower upper represent values transformation. documentation can found -depth tutorial","code":"pset = ps(   z = p_int(lower = -3, upper = 3),   x = p_dbl(lower = 2^-3, upper = 2^3, logscale = TRUE) ) pset$extra_trafo = function(x, param_set) {   x$z = 2^x$z   return(x) } pset_smplr = SamplerUnif$new(pset) x = pset_smplr$sample(2) xst = x$transpose() xst #> [[1]] #> [[1]]$z #> [1] 0.125 #>  #> [[1]]$x #> [1] 0.6985067 #>  #>  #> [[2]] #> [[2]]$z #> [1] 0.5 #>  #> [[2]]$x #> [1] 0.5795772"},{"path":"https://paradox.mlr-org.com/reference/Condition.html","id":null,"dir":"Reference","previous_headings":"","what":"Dependency Condition — condition_test","title":"Dependency Condition — condition_test","text":"Condition object, specify condition dependency.","code":""},{"path":"https://paradox.mlr-org.com/reference/Condition.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dependency Condition — condition_test","text":"","code":"condition_test(cond, x)  condition_as_string(cond, lhs_chr = \"x\")  Condition(rhs, condition_format_string)"},{"path":"https://paradox.mlr-org.com/reference/Condition.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dependency Condition — condition_test","text":"cond (Condition)Condition use x () Value test lhs_chr (character(1)) Symbolic representation use <lhs> returned string. rhs () Right-hand-side condition. condition_format_string (character(1)) Format-string representing condition pretty-printing condition_as_string(). contain two %s, used sprintf()-call two string values.","code":""},{"path":"https://paradox.mlr-org.com/reference/Condition.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Dependency Condition — condition_test","text":"condition_test(): Used internally. Tests whether value satisfies given condition. Vectorizes x atomic. condition_as_string(): Used internally. Returns string represents condition pretty printing, form \"<lhs> <relation> <rhs>\", e.g. \"x == 3\" \"param %% {1, 2, 10}\".","code":""},{"path":"https://paradox.mlr-org.com/reference/Condition.html","id":"currently-implemented-simple-conditions","dir":"Reference","previous_headings":"","what":"Currently implemented simple conditions","title":"Dependency Condition — condition_test","text":"CondEqual(rhs)  Value must equal rhs. CondAnyOf(rhs)  Value must value rhs.","code":""},{"path":"https://paradox.mlr-org.com/reference/Design.html","id":null,"dir":"Reference","previous_headings":"","what":"Design of Configurations — Design","title":"Design of Configurations — Design","text":"lightweight wrapper around ParamSet data.table::data.table(), latter design configurations produced former - e.g., calling generate_design_grid() sampling.","code":""},{"path":"https://paradox.mlr-org.com/reference/Design.html","id":"public-fields","dir":"Reference","previous_headings":"","what":"Public fields","title":"Design of Configurations — Design","text":"param_set (ParamSet). data (data.table::data.table()) Stored data.","code":""},{"path":[]},{"path":"https://paradox.mlr-org.com/reference/Design.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Design of Configurations — Design","text":"Design$new() Design$format() Design$print() Design$transpose() Design$clone()","code":""},{"path":"https://paradox.mlr-org.com/reference/Design.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Design of Configurations — Design","text":"Creates new instance R6 class.","code":""},{"path":"https://paradox.mlr-org.com/reference/Design.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Design of Configurations — Design","text":"","code":"Design$new(param_set, data, remove_dupl)"},{"path":"https://paradox.mlr-org.com/reference/Design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Design of Configurations — Design","text":"param_set (ParamSet). data (data.table::data.table()) Stored data. remove_dupl (logical(1)) Remove duplicates?","code":""},{"path":"https://paradox.mlr-org.com/reference/Design.html","id":"method-format-","dir":"Reference","previous_headings":"","what":"Method format()","title":"Design of Configurations — Design","text":"Helper print outputs.","code":""},{"path":"https://paradox.mlr-org.com/reference/Design.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Design of Configurations — Design","text":"","code":"Design$format(...)"},{"path":"https://paradox.mlr-org.com/reference/Design.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Design of Configurations — Design","text":"... (ignored).","code":""},{"path":"https://paradox.mlr-org.com/reference/Design.html","id":"method-print-","dir":"Reference","previous_headings":"","what":"Method print()","title":"Design of Configurations — Design","text":"Printer.","code":""},{"path":"https://paradox.mlr-org.com/reference/Design.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Design of Configurations — Design","text":"","code":"Design$print(...)"},{"path":"https://paradox.mlr-org.com/reference/Design.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Design of Configurations — Design","text":"... (ignored).","code":""},{"path":"https://paradox.mlr-org.com/reference/Design.html","id":"method-transpose-","dir":"Reference","previous_headings":"","what":"Method transpose()","title":"Design of Configurations — Design","text":"Converts data list lists row-configurations, possibly removes NA entries inactive parameter values due unsatisfied dependencies, possibly calls trafo function ParamSet.","code":""},{"path":"https://paradox.mlr-org.com/reference/Design.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Design of Configurations — Design","text":"","code":"Design$transpose(filter_na = TRUE, trafo = TRUE)"},{"path":"https://paradox.mlr-org.com/reference/Design.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"Design of Configurations — Design","text":"filter_na (logical(1)) NA entries inactive parameter values due unsatisfied dependencies removed? trafo (logical(1)) trafo function ParamSet called?","code":""},{"path":"https://paradox.mlr-org.com/reference/Design.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Design of Configurations — Design","text":"objects class cloneable method.","code":""},{"path":"https://paradox.mlr-org.com/reference/Design.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"Design of Configurations — Design","text":"","code":"Design$clone(deep = FALSE)"},{"path":"https://paradox.mlr-org.com/reference/Design.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"Design of Configurations — Design","text":"deep Whether make deep clone.","code":""},{"path":"https://paradox.mlr-org.com/reference/Domain.html","id":null,"dir":"Reference","previous_headings":"","what":"Domain: Parameter Range without an Id — Domain","title":"Domain: Parameter Range without an Id — Domain","text":"Domain object representation single dimension ParamSet. Domain objects used construct ParamSets, either ps() short form, ParamSet constructor , ParamSet$search_space() mechanism (see to_tune()). basic parameter classes (\"ParamInt\", \"ParamDbl\", \"ParamLgl\", \"ParamFct\", \"ParamUty\") function constructing Domain object (p_int(), p_dbl(), p_lgl(), p_fct(), p_uty()). fitting construction arguments control bounds behavior. Domain objects representations parameter ranges intermediate objects used short form constructions to_tune() ps(). nature, modified user, constructed. Domain object's internals subject change relied upon.","code":""},{"path":"https://paradox.mlr-org.com/reference/Domain.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Domain: Parameter Range without an Id — Domain","text":"","code":"p_dbl(   lower = -Inf,   upper = Inf,   special_vals = list(),   default = NO_DEF,   tags = character(),   tolerance = sqrt(.Machine$double.eps),   depends = NULL,   trafo = NULL,   logscale = FALSE,   init,   aggr = NULL,   in_tune_fn = NULL,   disable_in_tune = NULL )  p_fct(   levels,   special_vals = list(),   default = NO_DEF,   tags = character(),   depends = NULL,   trafo = NULL,   init,   aggr = NULL,   in_tune_fn = NULL,   disable_in_tune = NULL )  p_int(   lower = -Inf,   upper = Inf,   special_vals = list(),   default = NO_DEF,   tags = character(),   tolerance = sqrt(.Machine$double.eps),   depends = NULL,   trafo = NULL,   logscale = FALSE,   init,   aggr = NULL,   in_tune_fn = NULL,   disable_in_tune = NULL )  p_lgl(   special_vals = list(),   default = NO_DEF,   tags = character(),   depends = NULL,   trafo = NULL,   init,   aggr = NULL,   in_tune_fn = NULL,   disable_in_tune = NULL )  p_uty(   custom_check = NULL,   special_vals = list(),   default = NO_DEF,   tags = character(),   depends = NULL,   trafo = NULL,   repr = substitute(default),   init,   aggr = NULL,   in_tune_fn = NULL,   disable_in_tune = NULL )"},{"path":"https://paradox.mlr-org.com/reference/Domain.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Domain: Parameter Range without an Id — Domain","text":"lower (numeric(1)) Lower bound, can -Inf. upper (numeric(1)) Upper bound can +Inf. special_vals (list()) Arbitrary special values parameter allowed take, make feasible. allows extending domain parameter. Note values used feasibility checks, neither generating designs sampling. default () Default value. Can domain parameter element special_vals. value NO_DEF default exists. NULL can valid default. value effect ParamSet$values behavior ParamSet$check(), $test() $assert(). default intended used documentation purposes. ` tags (character()) Arbitrary tags group subset parameters. tags serve special purpose: \"required\" implies parameters given setting values ParamSet. tolerance (numeric(1)) Initializes $tolerance field determines depends (call | expression) expression indicating requirement parameter constructed . Can given expression (using quote()), expression can entered directly parsed using NSE (see examples). expression may form <Param> == <value> <Param> %% <values>, result dependencies according ParamSet$add_dep(= \"<Param>\", cond = CondEqual(<value>)) ParamSet$add_dep(= \"<Param>\", cond = CondAnyOf(<values>)), respectively (see CondEqual, CondAnyOf). expression may also contain multiple conditions separated &&. trafo (function) Single argument function performing transformation parameter. Domain used construct ParamSet, transformation applied corresponding parameter part $trafo function. Note trafo inherited TuneTokens! Defining parameter e.g. p_dbl(..., trafo = ...) automatically give to_tune() assigned transformation. trafo makes sense ParamSets get used search spaces optimization tuning, useful defining domains hyperparameter ranges learning algorithms, use trafos. logscale (logical(1)) Put numeric domains log scale. Default FALSE. Log-scale Domains represent parameter ranges lower upper bounds logarithmized, trafo added exponentiates sampled values original scale. setting trafo = exp, logscale = TRUE handle parameter bounds internally: p_dbl(1, 10, logscale = TRUE) results parameter lower bound 0, upper bound log(10), uses exp transformation . Therefore, given bounds represent bounds transformation. (see examples).p_int() logscale = TRUE results continuous parameter similar p_dbl(), integer-valued parameter, bounds log(max(lower, 0.5)) ... log(upper + 1) trafo similar \".integer(exp(x))\" (additional bounds correction). lower bound lifted 0.5 lower 0 handle lower == 0 case. upper bound increased log(upper + 1) trafo otherwise almost never generate value upper. logscale TRUE, upper bounds may infinite, lower bounds greater 0 p_dbl() greater equal 0 p_int(). Note \"logscale\" inherited TuneTokens! Defining parameter p_dbl(... logscale = TRUE) automatically give to_tune() assigned log-scale. logscale makes sense ParamSets get used search spaces optimization tuning, useful defining domains hyperparameter ranges learning algorithms, use trafos.logscale happens natural (e == 2.718282...) basis. aware using different base (log10()/10^, log2()/2^) completely equivalent change values sampled transformation. init () Initial value. given, corresponding entry ParamSet$values initialized value upon construction. aggr (function) Default aggregation function parameter. Can given parameters tagged \"internal_tuning\". Function one argument, list parameter values returns aggregated parameter value. in_tune_fn (function(domain, param_vals)) Function converters Domain object parameter value. Can given parameters tagged \"internal_tuning\". function also assert parameters required enable internal tuning given domain set param_vals (early_stopping_rounds XGBoost). disable_in_tune (named list()) parameter values need set ParamSet disable internal tuning parameter. XGBoost e.g. list(early_stopping_rounds = NULL). levels (character | atomic | list) Allowed categorical values parameter. character, trafo generated converts names (given: .character() values) levels argument values. trafo performed function given trafo argument. custom_check (function()) Custom function check feasibility. Function checks input. Must return 'TRUE' input valid character(1) error message otherwise. function throw error. Defaults NULL, means check performed. repr (language) Symbol use represent value given default. deparse() object used printing domain, cases.","code":""},{"path":"https://paradox.mlr-org.com/reference/Domain.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Domain: Parameter Range without an Id — Domain","text":"Domain object.","code":""},{"path":"https://paradox.mlr-org.com/reference/Domain.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Domain: Parameter Range without an Id — Domain","text":"Although levels values constructed p_fct() always character-valued, p_fct function admits levels argument goes beyond : Besides character vector, atomic vector list (optionally named) may given. (value list named, names inferred using .character() values.) resulting Domain correspond range values given names levels argument trafo maps character names arbitrary values levels argument.","code":""},{"path":[]},{"path":"https://paradox.mlr-org.com/reference/Domain.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Domain: Parameter Range without an Id — Domain","text":"","code":"params = ps(   unbounded_integer = p_int(),   bounded_double = p_dbl(0, 10),   half_bounded_integer = p_dbl(1),   half_bounded_double = p_dbl(upper = 1),   double_with_trafo = p_dbl(-1, 1, trafo = exp),   extra_double = p_dbl(0, 1, special_vals = list(\"xxx\"), tags = \"tagged\"),   factor_param = p_fct(c(\"a\", \"b\", \"c\")),   factor_param_with_implicit_trafo = p_fct(list(a = 1, b = 2, c = list())) ) print(params) #> <ParamSet(8)> #>                                  id    class lower upper nlevels        default #>                              <char>   <char> <num> <num>   <num>         <list> #> 1:                unbounded_integer ParamInt  -Inf   Inf     Inf <NoDefault[0]> #> 2:                   bounded_double ParamDbl     0    10     Inf <NoDefault[0]> #> 3:             half_bounded_integer ParamDbl     1   Inf     Inf <NoDefault[0]> #> 4:              half_bounded_double ParamDbl  -Inf     1     Inf <NoDefault[0]> #> 5:                double_with_trafo ParamDbl    -1     1     Inf <NoDefault[0]> #> 6:                     extra_double ParamDbl     0     1     Inf <NoDefault[0]> #> 7:                     factor_param ParamFct    NA    NA       3 <NoDefault[0]> #> 8: factor_param_with_implicit_trafo ParamFct    NA    NA       3 <NoDefault[0]> #>     value #>    <list> #> 1:        #> 2:        #> 3:        #> 4:        #> 5:        #> 6:        #> 7:        #> 8:        #> Trafo is set.  params$trafo(list(   bounded_double = 1,   double_with_trafo = 1,   factor_param = \"c\",   factor_param_with_implicit_trafo = \"c\" )) #> $bounded_double #> [1] 1 #>  #> $double_with_trafo #> [1] 2.718282 #>  #> $factor_param #> [1] \"c\" #>  #> $factor_param_with_implicit_trafo #> list() #>   # logscale: params = ps(x = p_dbl(1, 100, logscale = TRUE))  # The ParamSet has bounds log(1) .. log(100): print(params) #> <ParamSet(1)> #>        id    class lower   upper nlevels        default  value #>    <char>   <char> <num>   <num>   <num>         <list> <list> #> 1:      x ParamDbl     0 4.60517     Inf <NoDefault[0]>        #> Trafo is set.  # When generating a equidistant grid, it is equidistant within log values grid = generate_design_grid(params, 3) print(grid) #> <Design> with 3 rows: #>           x #>       <num> #> 1: 0.000000 #> 2: 2.302585 #> 3: 4.605170  # But the values are on a log scale with desired bounds after trafo print(grid$transpose()) #> [[1]] #> [[1]]$x #> [1] 1 #>  #>  #> [[2]] #> [[2]]$x #> [1] 10 #>  #>  #> [[3]] #> [[3]]$x #> [1] 100 #>  #>   # Integer parameters with logscale are `p_dbl()`s pre-trafo params = ps(x = p_int(0, 10, logscale = TRUE)) print(params) #> <ParamSet(1)> #>        id    class      lower    upper nlevels        default  value #>    <char>   <char>      <num>    <num>   <num>         <list> <list> #> 1:      x ParamDbl -0.6931472 2.397895     Inf <NoDefault[0]>        #> Trafo is set.  grid = generate_design_grid(params, 4) print(grid) #> <Design> with 4 rows: #>             x #>         <num> #> 1: -0.6931472 #> 2:  0.3372003 #> 3:  1.3675478 #> 4:  2.3978953  # ... but get transformed to integers. print(grid$transpose()) #> [[1]] #> [[1]]$x #> [1] 0 #>  #>  #> [[2]] #> [[2]]$x #> [1] 1 #>  #>  #> [[3]] #> [[3]]$x #> [1] 3 #>  #>  #> [[4]] #> [[4]]$x #> [1] 10 #>  #>    # internal tuning  param_set = ps(   iters = p_int(0, Inf, tags = \"internal_tuning\", aggr = function(x) round(mean(unlist(x))),     in_tune_fn = function(domain, param_vals) {       stopifnot(domain$lower <= 1)       stopifnot(param_vals$early_stopping == TRUE)       domain$upper     },     disable_in_tune = list(early_stopping = FALSE)),   early_stopping = p_lgl() ) param_set$set_values(   iters = to_tune(upper = 100, internal = TRUE),   early_stopping = TRUE ) param_set$convert_internal_search_space(param_set$search_space()) #> $iters #> [1] 100 #>  param_set$aggr_internal_tuned_values(   list(iters = list(1, 2, 3)) ) #> $iters #> [1] 2 #>   param_set$disable_internal_tuning(\"iters\") param_set$values$early_stopping #> [1] FALSE"},{"path":"https://paradox.mlr-org.com/reference/NO_DEF.html","id":null,"dir":"Reference","previous_headings":"","what":"Extra data type for ","title":"Extra data type for ","text":"Special new data type -default. often needed end-user, mainly internal. NO_DEF: Singleton object type, used Domain default given. is_nodefault(): object 'default' object?","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":null,"dir":"Reference","previous_headings":"","what":"ParamSet — ParamSet","title":"ParamSet — ParamSet","text":"object representing space possible parametrizations function another object. ParamSets used side objects parameterized, function configuration space determining set possible configurations accepted objects. can also used specify search spaces optimization, indicating set legal configurations try . often convenient generate search spaces configuration spaces, can done using $search_space() method combination to_tune() / TuneToken objects. Individual dimensions ParamSet specified Domain objects, created p_dbl(), p_lgl() etc. field $values can used store active configuration partially fix parameters constant values -- precise effect can determined object parameterized. Constructing ParamSet can done using ParamSet$new() combination named list Domain objects. route recommended set dimensions (.e. members named list) dynamically created, number parameters variable. ParamSets can also created using ps() shorthand, recommended way set parameters fixed. practice, majority cases ParamSet created, ps() used.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"s-methods-and-type-converters","dir":"Reference","previous_headings":"","what":"S3 methods and type converters","title":"ParamSet — ParamSet","text":".data.table()ParamSet -> data.table::data.table() Compact representation datatable. Col types : id: character class: character lower, upper: numeric levels: list col, NULL elements nlevels: integer valued numeric is_bounded: logical special_vals: list col list default: list col storage_type: character tags: list col character vectors","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"public-fields","dir":"Reference","previous_headings":"","what":"Public fields","title":"ParamSet — ParamSet","text":"assert_values (logical(1)) values checked validity assigment active binding $values? Default TRUE, switch know .","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"active-bindings","dir":"Reference","previous_headings":"","what":"Active bindings","title":"ParamSet — ParamSet","text":"data (data.table) data.table representation ParamSet. values (named list()) Currently set / fixed parameter values. Settable, feasibility values checked set . set values parameters, subset. set values, previously set values unset / removed. tags (named list() character()) Can used group subset parameters. Named parameter IDs. params (named list())data.table representing combined Domain objects used construct ParamSet. Used internal purpuses. use external code deprecated. domains (named list Domain) List Domain objects used initialize ParamSet. extra_trafo (function(x, param_set)) Transformation function. Settable. User pass function(x), form (named list(), ParamSet) -> named list(). function responsible transform feasible configuration another encoding, potentially evaluating configuration target algorithm. output, many things hold. needs unique names, target algorithm accept configuration. convenience, self-paramset also passed , need info (e.g. tags). NULL default, can set NULL switch transformation . constraint (function(x)) Constraint function. Settable. function must evaluate named list() values determine whether satisfies constraints, returning scalar logical(1) value. deps (data.table::data.table()) Table cols id (character(1)) (character(1)) cond (Condition). Lists (direct) dependency parents param, parameter IDs. Internally created call add_dep. Settable, want remove dependencies perform changes. length (integer(1)) Number contained parameters. is_empty (logical(1)) ParamSet empty? Named parameter IDs. has_trafo (logical(1)) Whether trafo function present, parameters extra_trafo. has_extra_trafo (logical(1)) Whether extra_trafo set. has_deps (logical(1)) Whether parameter dependencies present has_constraint (logical(1)) Whether parameter constraint set. all_numeric (logical(1)) TRUE parameters p_dbl() p_int(). all_categorical (logical(1)) TRUE parameters p_fct() p_lgl(). all_bounded (logical(1)) TRUE parameters bounded. class (named character()) Classes contained parameters. Named parameter IDs. lower (named double()) Lower bounds numeric parameters (NA non-numerics). Named parameter IDs. upper (named double()) Upper bounds numeric parameters (NA non-numerics). Named parameter IDs. levels (named list() character) Allowed levels categorical parameters (NULL non-categoricals). Named parameter IDs. storage_type (character()) Data types parameters stored tables. Named parameter IDs. special_vals (named list() list()) Special values parameters. Named parameter IDs. default (named list()) Default values parameters. default exists, element present. Named parameter IDs. has_trafo_param (logical()) Whether trafo set parameter. is_logscale (logical()) Whether trafo set logscale construction. Note refers logscale flag set construction, e.g. p_dbl(logscale = TRUE). parameter set logscale manually, e.g. p_dbl(trafo = exp), is_logscale FALSE. nlevels (named integer()) Number distinct levels parameters. Inf double parameters unbounded integer parameters. Named param IDs. is_number (named logical()) Whether parameter p_dbl() p_int(). Named parameter IDs. is_categ (named logical()) Whether parameter p_fct() p_lgl(). Named parameter IDs. is_bounded (named logical()) Whether parameters finite bounds. Named parameter IDs.","code":""},{"path":[]},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"ParamSet — ParamSet","text":"ParamSet$new() ParamSet$ids() ParamSet$get_values() ParamSet$set_values() ParamSet$trafo() ParamSet$aggr_internal_tuned_values() ParamSet$disable_internal_tuning() ParamSet$convert_internal_search_space() ParamSet$test_constraint() ParamSet$test_constraint_dt() ParamSet$check() ParamSet$check_dependencies() ParamSet$test() ParamSet$assert() ParamSet$check_dt() ParamSet$test_dt() ParamSet$assert_dt() ParamSet$qunif() ParamSet$get_domain() ParamSet$subset() ParamSet$subspaces() ParamSet$flatten() ParamSet$search_space() ParamSet$add_dep() ParamSet$format() ParamSet$print() ParamSet$clone()","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"ParamSet — ParamSet","text":"Creates new instance R6 class.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSet — ParamSet","text":"","code":"ParamSet$new(params = named_list(), allow_dangling_dependencies = FALSE)"},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSet — ParamSet","text":"params (named list()) List Domain, named respective ID. allow_dangling_dependencies (character(1)) Whether dependencies depending parameters present allowed. parameter x depends = y == 0 y present usually throw error, dangling dependencies allowed, dependency added regardless. mainly internal use.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"method-ids-","dir":"Reference","previous_headings":"","what":"Method ids()","title":"ParamSet — ParamSet","text":"Retrieves IDs contained parameters based filter criteria selections, NULL means restriction. returns IDs parameters satisfy conditions.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSet — ParamSet","text":"","code":"ParamSet$ids(class = NULL, tags = NULL, any_tags = NULL)"},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSet — ParamSet","text":"class (character()) Typically subset \"ParamDbl\", \"ParamInt\", \"ParamFct\", \"ParamLgl\", \"ParamUty\". classes possible implemented 3rd party packages. Return IDs dimensions given class. tags (character()). Return IDs dimensions tags given argument. any_tags (character()). Return IDs dimensions least one tags given argument.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"ParamSet — ParamSet","text":"character().","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"method-get-values-","dir":"Reference","previous_headings":"","what":"Method get_values()","title":"ParamSet — ParamSet","text":"Retrieves parameter values based selections, NULL means restriction equivalent $values. returns values parameters satisfy conditions.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSet — ParamSet","text":"","code":"ParamSet$get_values(   class = NULL,   tags = NULL,   any_tags = NULL,   type = \"with_token\",   check_required = TRUE,   remove_dependencies = TRUE )"},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSet — ParamSet","text":"class (character()). See $ids(). tags (character()). See $ids(). any_tags (character()). See $ids(). type (character(1)) Return values \"with_token\" (.e. values), check_required (logical(1)) Check required parameters set? remove_dependencies (logical(1)) TRUE, set values dependencies fulfilled NULL.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"ParamSet — ParamSet","text":"Named list().","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"method-set-values-","dir":"Reference","previous_headings":"","what":"Method set_values()","title":"ParamSet — ParamSet","text":"Allows modify (overwrite) replace parameter values. Per default already set values kept unless new values provided.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSet — ParamSet","text":"","code":"ParamSet$set_values(..., .values = list(), .insert = TRUE)"},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSet — ParamSet","text":"... () Named parameter values. .values (named list()) Named list parameter values. Names must already appear .... .insert (logical(1)) Whether insert values (old values kept, overwritten), replace values. Default TRUE.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"method-trafo-","dir":"Reference","previous_headings":"","what":"Method trafo()","title":"ParamSet — ParamSet","text":"Perform transformation specified trafo Domain objects, well $extra_trafo field.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSet — ParamSet","text":"","code":"ParamSet$trafo(x, param_set = self)"},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSet — ParamSet","text":"x (named list() | data.frame) value(s) transformed. param_set (ParamSet) Passed extra_trafo(). Note extra_trafo self used, extra_trafo ParamSet given param_set argument. almost cases, default param_set = self used.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"method-aggr-internal-tuned-values-","dir":"Reference","previous_headings":"","what":"Method aggr_internal_tuned_values()","title":"ParamSet — ParamSet","text":"Aggregate parameter values according aggregation rules.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSet — ParamSet","text":"","code":"ParamSet$aggr_internal_tuned_values(x)"},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSet — ParamSet","text":"x (named list() list()s) value(s) aggregated. Names parameter values. aggregation function selected based parameter.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"returns-2","dir":"Reference","previous_headings":"","what":"Returns","title":"ParamSet — ParamSet","text":"(named list())","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"method-disable-internal-tuning-","dir":"Reference","previous_headings":"","what":"Method disable_internal_tuning()","title":"ParamSet — ParamSet","text":"Set parameter values internal tuning selected parameters disabled.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSet — ParamSet","text":"","code":"ParamSet$disable_internal_tuning(ids)"},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSet — ParamSet","text":"ids (character()) ids parameters disable internal tuning.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"returns-3","dir":"Reference","previous_headings":"","what":"Returns","title":"ParamSet — ParamSet","text":"Self","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"method-convert-internal-search-space-","dir":"Reference","previous_headings":"","what":"Method convert_internal_search_space()","title":"ParamSet — ParamSet","text":"Convert parameters search space parameter values using transformation given in_tune_fn.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSet — ParamSet","text":"","code":"ParamSet$convert_internal_search_space(search_space)"},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"arguments-7","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSet — ParamSet","text":"search_space (ParamSet) internal search space.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"returns-4","dir":"Reference","previous_headings":"","what":"Returns","title":"ParamSet — ParamSet","text":"(named list())","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"method-test-constraint-","dir":"Reference","previous_headings":"","what":"Method test_constraint()","title":"ParamSet — ParamSet","text":"checkmate-like test-function. Takes named list. Return FALSE given $constraint satisfied, TRUE otherwise. Note different satisfying bounds types given ParamSet : x satisfy , error thrown, given assert_value TRUE.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"usage-8","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSet — ParamSet","text":"","code":"ParamSet$test_constraint(x, assert_value = TRUE)"},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"arguments-8","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSet — ParamSet","text":"x (named list()) value test. assert_value (logical(1)) Whether verify x satisfies bounds types given ParamSet. TRUE unless already checked .","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"returns-5","dir":"Reference","previous_headings":"","what":"Returns","title":"ParamSet — ParamSet","text":"logical(1): Whether x satisfies $constraint.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"method-test-constraint-dt-","dir":"Reference","previous_headings":"","what":"Method test_constraint_dt()","title":"ParamSet — ParamSet","text":"checkmate-like test-function. Takes data.table. row, return FALSE given $constraint satisfied, TRUE otherwise. Note different satisfying bounds types given ParamSet : x satisfy , error thrown, given assert_value TRUE.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"usage-9","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSet — ParamSet","text":"","code":"ParamSet$test_constraint_dt(x, assert_value = TRUE)"},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"arguments-9","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSet — ParamSet","text":"x (data.table) values test. assert_value (logical(1)) Whether verify x satisfies bounds types given ParamSet. TRUE unless already checked .","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"returns-6","dir":"Reference","previous_headings":"","what":"Returns","title":"ParamSet — ParamSet","text":"logical: row x, whether satisfies $constraint.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"method-check-","dir":"Reference","previous_headings":"","what":"Method check()","title":"ParamSet — ParamSet","text":"checkmate-like check-function. Takes named list. point x feasible, configures subset params, individual param constraints satisfied dependencies satisfied. Params dependencies satisfied part x. Constraints dependencies checked check_strict FALSE.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"usage-10","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSet — ParamSet","text":"","code":"ParamSet$check(xs, check_strict = TRUE)"},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"arguments-10","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSet — ParamSet","text":"xs (named list()). check_strict (logical(1)) Whether check constraints dependencies satisfied.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"returns-7","dir":"Reference","previous_headings":"","what":"Returns","title":"ParamSet — ParamSet","text":"successful TRUE, string error message.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"method-check-dependencies-","dir":"Reference","previous_headings":"","what":"Method check_dependencies()","title":"ParamSet — ParamSet","text":"checkmate-like check-function. Takes named list. Checks individual param dependencies satisfied.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"usage-11","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSet — ParamSet","text":"","code":"ParamSet$check_dependencies(xs)"},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"arguments-11","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSet — ParamSet","text":"xs (named list()).","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"returns-8","dir":"Reference","previous_headings":"","what":"Returns","title":"ParamSet — ParamSet","text":"successful TRUE, string error message.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"method-test-","dir":"Reference","previous_headings":"","what":"Method test()","title":"ParamSet — ParamSet","text":"checkmate-like test-function. Takes named list. point x feasible, configures subset params, individual param constraints satisfied dependencies satisfied. Params dependencies satisfied part x. Constraints dependencies checked check_strict FALSE.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"usage-12","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSet — ParamSet","text":"","code":"ParamSet$test(xs, check_strict = TRUE)"},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"arguments-12","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSet — ParamSet","text":"xs (named list()). check_strict (logical(1)) Whether check constraints dependencies satisfied.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"returns-9","dir":"Reference","previous_headings":"","what":"Returns","title":"ParamSet — ParamSet","text":"successful TRUE, FALSE.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"method-assert-","dir":"Reference","previous_headings":"","what":"Method assert()","title":"ParamSet — ParamSet","text":"checkmate-like assert-function. Takes named list. point x feasible, configures subset params, individual param constraints satisfied dependencies satisfied. Params dependencies satisfied part x. Constraints dependencies checked check_strict FALSE.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"usage-13","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSet — ParamSet","text":"","code":"ParamSet$assert(xs, check_strict = TRUE, .var.name = vname(xs))"},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"arguments-13","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSet — ParamSet","text":"xs (named list()). check_strict (logical(1)) Whether check constraints dependencies satisfied. .var.name (character(1)) Name checked object print error messages. Defaults heuristic implemented vname.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"returns-10","dir":"Reference","previous_headings":"","what":"Returns","title":"ParamSet — ParamSet","text":"successful xs invisibly, error message.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"method-check-dt-","dir":"Reference","previous_headings":"","what":"Method check_dt()","title":"ParamSet — ParamSet","text":"checkmate-like check-function. Takes data.table::data.table rows points columns parameters. point x feasible, configures subset params, individual param constraints satisfied dependencies satisfied. Params dependencies satisfied part x. Constraints dependencies checked check_strict FALSE.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"usage-14","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSet — ParamSet","text":"","code":"ParamSet$check_dt(xdt, check_strict = TRUE)"},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"arguments-14","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSet — ParamSet","text":"xdt (data.table::data.table | data.frame()). check_strict (logical(1)) Whether check constraints dependencies satisfied.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"returns-11","dir":"Reference","previous_headings":"","what":"Returns","title":"ParamSet — ParamSet","text":"successful TRUE, string error message.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"method-test-dt-","dir":"Reference","previous_headings":"","what":"Method test_dt()","title":"ParamSet — ParamSet","text":"checkmate-like test-function (s. $check_dt()).","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"usage-15","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSet — ParamSet","text":"","code":"ParamSet$test_dt(xdt, check_strict = TRUE)"},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"arguments-15","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSet — ParamSet","text":"xdt (data.table::data.table). check_strict (logical(1)) Whether check constraints dependencies satisfied.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"returns-12","dir":"Reference","previous_headings":"","what":"Returns","title":"ParamSet — ParamSet","text":"successful TRUE, FALSE.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"method-assert-dt-","dir":"Reference","previous_headings":"","what":"Method assert_dt()","title":"ParamSet — ParamSet","text":"checkmate-like assert-function (s. $check_dt()).","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"usage-16","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSet — ParamSet","text":"","code":"ParamSet$assert_dt(xdt, check_strict = TRUE, .var.name = vname(xdt))"},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"arguments-16","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSet — ParamSet","text":"xdt (data.table::data.table). check_strict (logical(1)) Whether check constraints dependencies satisfied. .var.name (character(1)) Name checked object print error messages. Defaults heuristic implemented vname.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"returns-13","dir":"Reference","previous_headings":"","what":"Returns","title":"ParamSet — ParamSet","text":"successful xs invisibly, , error generated.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"method-qunif-","dir":"Reference","previous_headings":"","what":"Method qunif()","title":"ParamSet — ParamSet","text":"Map matrix data.frame values 0 1 proportional values inside feasible intervals individual parameters.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"usage-17","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSet — ParamSet","text":"","code":"ParamSet$qunif(x)"},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"arguments-17","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSet — ParamSet","text":"x (matrix | data.frame) Values map. Column names must subset names parameters.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"returns-14","dir":"Reference","previous_headings":"","what":"Returns","title":"ParamSet — ParamSet","text":"data.table.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"method-get-domain-","dir":"Reference","previous_headings":"","what":"Method get_domain()","title":"ParamSet — ParamSet","text":"get Domain object used create given parameter.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"usage-18","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSet — ParamSet","text":"","code":"ParamSet$get_domain(id)"},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"arguments-18","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSet — ParamSet","text":"id (character(1)).","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"returns-15","dir":"Reference","previous_headings":"","what":"Returns","title":"ParamSet — ParamSet","text":"Domain.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"method-subset-","dir":"Reference","previous_headings":"","what":"Method subset()","title":"ParamSet — ParamSet","text":"Create new ParamSet restricted passed IDs.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"usage-19","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSet — ParamSet","text":"","code":"ParamSet$subset(   ids,   allow_dangling_dependencies = FALSE,   keep_constraint = TRUE )"},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"arguments-19","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSet — ParamSet","text":"ids (character()). allow_dangling_dependencies (logical(1)) Whether allow subsets cut across parameter dependencies. Dependencies point dropped parameters kept (\"dangling\", .e. \"\" present). keep_constraint (logical(1)) Whether keep $constraint function.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"returns-16","dir":"Reference","previous_headings":"","what":"Returns","title":"ParamSet — ParamSet","text":"ParamSet.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"method-subspaces-","dir":"Reference","previous_headings":"","what":"Method subspaces()","title":"ParamSet — ParamSet","text":"Create new one-dimensional ParamSets dimension.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"usage-20","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSet — ParamSet","text":"","code":"ParamSet$subspaces(ids = private$.params$id)"},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"arguments-20","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSet — ParamSet","text":"ids (character()) IDs create ParamSets. Defaults IDs.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"returns-17","dir":"Reference","previous_headings":"","what":"Returns","title":"ParamSet — ParamSet","text":"named list() ParamSet.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"method-flatten-","dir":"Reference","previous_headings":"","what":"Method flatten()","title":"ParamSet — ParamSet","text":"Create ParamSet object, even object ParamSet e.g. ParamSetCollection.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"usage-21","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSet — ParamSet","text":"","code":"ParamSet$flatten()"},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"method-search-space-","dir":"Reference","previous_headings":"","what":"Method search_space()","title":"ParamSet — ParamSet","text":"Construct ParamSet tune . Constructed TuneToken $values, see to_tune().","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"usage-22","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSet — ParamSet","text":"","code":"ParamSet$search_space(values = self$values)"},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"arguments-21","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSet — ParamSet","text":"values (named list): optional named list TuneToken objects convert, place $values.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"method-add-dep-","dir":"Reference","previous_headings":"","what":"Method add_dep()","title":"ParamSet — ParamSet","text":"Adds dependency set, param id now depends param .","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"usage-23","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSet — ParamSet","text":"","code":"ParamSet$add_dep(id, on, cond, allow_dangling_dependencies = FALSE)"},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"arguments-22","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSet — ParamSet","text":"id (character(1)). (character(1)). cond (Condition). allow_dangling_dependencies (logical(1)): Whether allow dependencies parameters present.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"method-format-","dir":"Reference","previous_headings":"","what":"Method format()","title":"ParamSet — ParamSet","text":"Helper print outputs.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"usage-24","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSet — ParamSet","text":"","code":"ParamSet$format()"},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"arguments-23","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSet — ParamSet","text":"... (ignored).","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"method-print-","dir":"Reference","previous_headings":"","what":"Method print()","title":"ParamSet — ParamSet","text":"Printer.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"usage-25","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSet — ParamSet","text":"","code":"ParamSet$print(   ...,   hide_cols = c(\"levels\", \"is_bounded\", \"special_vals\", \"tags\", \"storage_type\") )"},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"arguments-24","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSet — ParamSet","text":"... (ignored). hide_cols (character()) fields printed? Default \"levels\", \"is_bounded\", \"special_vals\", \"tags\", \"storage_type\".","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"ParamSet — ParamSet","text":"objects class cloneable method.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"usage-26","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSet — ParamSet","text":"","code":"ParamSet$clone(deep = FALSE)"},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"arguments-25","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSet — ParamSet","text":"deep Whether make deep clone.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ParamSet — ParamSet","text":"","code":"pset = ParamSet$new(   params = list(     d = p_dbl(lower = -5, upper = 5, default = 0, trafo = function(x) 2^x),     f = p_fct(levels = letters[1:3])   ) )  # alternative, recommended way of construction in this case since the # parameter list is not dynamic: pset = ps(   d = p_dbl(lower = -5, upper = 5, default = 0, trafo = function(x) 2^x),   f = p_fct(levels = letters[1:3]) )  pset$check(list(d = 2.1, f = \"a\")) #> [1] TRUE  pset$check(list(d = 2.1, f = \"d\")) #> [1] \"f: Must be element of set {'a','b','c'}, but is 'd'\""},{"path":"https://paradox.mlr-org.com/reference/ParamSetCollection.html","id":null,"dir":"Reference","previous_headings":"","what":"ParamSetCollection — ParamSetCollection","title":"ParamSetCollection — ParamSetCollection","text":"collection multiple ParamSet objects. collection basically light-weight wrapper / container around references multiple sets. order ensure unique param names, every param collection referred \"<set_id>.<param_id>\", <set_id> name entry given ParamSet named list given construction. Parameters ParamSet empty (.e. \"\") set_id referenced directly. Multiple ParamSets set_id \"\" can combined, parameter names may overlap avoid name clashes. either ask 'values' set , operation delegated individual, contained ParamSet references. collection maintain values state. also implies directly change values one referenced sets, change reflected collection. Dependencies: possible currently handle dependencies regarding parameters inside set - case simply add dependency set, best adding set collection across sets, param one set depends state param another set - case add call add_dep collection. call deps collection, returned complete table dependencies, sets across sets.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSetCollection.html","id":"super-class","dir":"Reference","previous_headings":"","what":"Super class","title":"ParamSetCollection — ParamSetCollection","text":"paradox::ParamSet -> ParamSetCollection","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSetCollection.html","id":"active-bindings","dir":"Reference","previous_headings":"","what":"Active bindings","title":"ParamSetCollection — ParamSetCollection","text":"deps (data.table::data.table()) Table cols id (character(1)) (character(1)) cond (Condition). Lists (direct) dependency parents param, parameter IDs. Internally created call add_dep. Settable, want remove dependencies perform changes. values (named list()) Currently set / fixed parameter values. Settable, feasibility values checked set . set values parameters, subset. set values, previously set values unset / removed. extra_trafo (function(x, param_set)) Transformation function. Settable. User pass function(x), form (named list(), ParamSet) -> named list(). function responsible transform feasible configuration another encoding, potentially evaluating configuration target algorithm. output, many things hold. needs unique names, target algorithm accept configuration. convenience, self-paramset also passed , need info (e.g. tags). NULL default, can set NULL switch transformation . constraint (function(x)) Constraint function. Settable. function must evaluate named list() values determine whether satisfies constraints, returning scalar logical(1) value. sets (named list()) Read-list ParamSets contained ParamSetCollection. field provides direct references ParamSet objects.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSetCollection.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"ParamSetCollection — ParamSetCollection","text":"paradox::ParamSet$add_dep() paradox::ParamSet$aggr_internal_tuned_values() paradox::ParamSet$assert() paradox::ParamSet$assert_dt() paradox::ParamSet$check() paradox::ParamSet$check_dependencies() paradox::ParamSet$check_dt() paradox::ParamSet$format() paradox::ParamSet$get_domain() paradox::ParamSet$get_values() paradox::ParamSet$ids() paradox::ParamSet$print() paradox::ParamSet$qunif() paradox::ParamSet$search_space() paradox::ParamSet$set_values() paradox::ParamSet$subset() paradox::ParamSet$subspaces() paradox::ParamSet$test() paradox::ParamSet$test_constraint() paradox::ParamSet$test_constraint_dt() paradox::ParamSet$test_dt() paradox::ParamSet$trafo()","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSetCollection.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"ParamSetCollection — ParamSetCollection","text":"ParamSetCollection$new() ParamSetCollection$add() ParamSetCollection$disable_internal_tuning() ParamSetCollection$convert_internal_search_space() ParamSetCollection$flatten() ParamSetCollection$clone()","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSetCollection.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"ParamSetCollection — ParamSetCollection","text":"Creates new instance R6 class.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSetCollection.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSetCollection — ParamSetCollection","text":"","code":"ParamSetCollection$new(sets, tag_sets = FALSE, tag_params = FALSE)"},{"path":"https://paradox.mlr-org.com/reference/ParamSetCollection.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSetCollection — ParamSetCollection","text":"sets (named list() ParamSet) ParamSet objects cloned. Names used \"set_id\" naming scheme delegated parameters. tag_sets (logical(1)) Whether add tags form \"set_<set_id>\" parameter originating given ParamSet given name <set_id>. tag_params (logical(1)) Whether add tags form \"param_<param_id>\" parameter original ID <param_id>.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSetCollection.html","id":"method-add-","dir":"Reference","previous_headings":"","what":"Method add()","title":"ParamSetCollection — ParamSetCollection","text":"Adds ParamSet collection.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSetCollection.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSetCollection — ParamSetCollection","text":"","code":"ParamSetCollection$add(p, n = \"\", tag_sets = FALSE, tag_params = FALSE)"},{"path":"https://paradox.mlr-org.com/reference/ParamSetCollection.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSetCollection — ParamSetCollection","text":"p (ParamSet). n (character(1)) Name use. Default \"\". tag_sets (logical(1)) Whether add tags form \"set_<n>\" newly added parameters. tag_params (logical(1)) Whether add tags form \"param_<param_id>\" parameter original ID <param_id>.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSetCollection.html","id":"method-disable-internal-tuning-","dir":"Reference","previous_headings":"","what":"Method disable_internal_tuning()","title":"ParamSetCollection — ParamSetCollection","text":"Set parameter values internal tuning selected parameters disabled.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSetCollection.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSetCollection — ParamSetCollection","text":"","code":"ParamSetCollection$disable_internal_tuning(ids)"},{"path":"https://paradox.mlr-org.com/reference/ParamSetCollection.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSetCollection — ParamSetCollection","text":"ids (character()) ids parameters disable internal tuning.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSetCollection.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"ParamSetCollection — ParamSetCollection","text":"Self","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSetCollection.html","id":"method-convert-internal-search-space-","dir":"Reference","previous_headings":"","what":"Method convert_internal_search_space()","title":"ParamSetCollection — ParamSetCollection","text":"Convert parameters search space parameter values using transformation given in_tune_fn.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSetCollection.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSetCollection — ParamSetCollection","text":"","code":"ParamSetCollection$convert_internal_search_space(search_space)"},{"path":"https://paradox.mlr-org.com/reference/ParamSetCollection.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSetCollection — ParamSetCollection","text":"search_space (ParamSet) internal search space.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSetCollection.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"ParamSetCollection — ParamSetCollection","text":"(named list())","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSetCollection.html","id":"method-flatten-","dir":"Reference","previous_headings":"","what":"Method flatten()","title":"ParamSetCollection — ParamSetCollection","text":"Create ParamSet ParamSetCollection.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSetCollection.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSetCollection — ParamSetCollection","text":"","code":"ParamSetCollection$flatten()"},{"path":"https://paradox.mlr-org.com/reference/ParamSetCollection.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"ParamSetCollection — ParamSetCollection","text":"objects class cloneable method.","code":""},{"path":"https://paradox.mlr-org.com/reference/ParamSetCollection.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"ParamSetCollection — ParamSetCollection","text":"","code":"ParamSetCollection$clone(deep = FALSE)"},{"path":"https://paradox.mlr-org.com/reference/ParamSetCollection.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"ParamSetCollection — ParamSetCollection","text":"deep Whether make deep clone.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler.html","id":null,"dir":"Reference","previous_headings":"","what":"Sampler Class — Sampler","title":"Sampler Class — Sampler","text":"abstract base class sampling objects like Sampler1D, SamplerHierarchical SamplerJointIndep.","code":""},{"path":[]},{"path":"https://paradox.mlr-org.com/reference/Sampler.html","id":"public-fields","dir":"Reference","previous_headings":"","what":"Public fields","title":"Sampler Class — Sampler","text":"param_set (ParamSet) Domain / support distribution want sample .","code":""},{"path":[]},{"path":"https://paradox.mlr-org.com/reference/Sampler.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Sampler Class — Sampler","text":"Sampler$new() Sampler$sample() Sampler$format() Sampler$print() Sampler$clone()","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Sampler Class — Sampler","text":"Creates new instance R6 class. Note object typically constructed via derived classes, e.g., Sampler1D.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sampler Class — Sampler","text":"","code":"Sampler$new(param_set)"},{"path":"https://paradox.mlr-org.com/reference/Sampler.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sampler Class — Sampler","text":"param_set (ParamSet) ParamSet associated Sampler.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler.html","id":"method-sample-","dir":"Reference","previous_headings":"","what":"Method sample()","title":"Sampler Class — Sampler","text":"Sample n values distribution.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Sampler Class — Sampler","text":"","code":"Sampler$sample(n)"},{"path":"https://paradox.mlr-org.com/reference/Sampler.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sampler Class — Sampler","text":"n (integer(1)).","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Sampler Class — Sampler","text":"Design.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler.html","id":"method-format-","dir":"Reference","previous_headings":"","what":"Method format()","title":"Sampler Class — Sampler","text":"Helper print outputs.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Sampler Class — Sampler","text":"","code":"Sampler$format(...)"},{"path":"https://paradox.mlr-org.com/reference/Sampler.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sampler Class — Sampler","text":"... (ignored).","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler.html","id":"method-print-","dir":"Reference","previous_headings":"","what":"Method print()","title":"Sampler Class — Sampler","text":"Printer.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Sampler Class — Sampler","text":"","code":"Sampler$print(...)"},{"path":"https://paradox.mlr-org.com/reference/Sampler.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sampler Class — Sampler","text":"... (ignored).","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Sampler Class — Sampler","text":"objects class cloneable method.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"Sampler Class — Sampler","text":"","code":"Sampler$clone(deep = FALSE)"},{"path":"https://paradox.mlr-org.com/reference/Sampler.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sampler Class — Sampler","text":"deep Whether make deep clone.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1D.html","id":null,"dir":"Reference","previous_headings":"","what":"Sampler1D Class — Sampler1D","title":"Sampler1D Class — Sampler1D","text":"1D sampler, abstract base class Sampler like Sampler1DUnif, Sampler1DRfun, Sampler1DCateg Sampler1DNormal.","code":""},{"path":[]},{"path":"https://paradox.mlr-org.com/reference/Sampler1D.html","id":"super-class","dir":"Reference","previous_headings":"","what":"Super class","title":"Sampler1D Class — Sampler1D","text":"paradox::Sampler -> Sampler1D","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1D.html","id":"active-bindings","dir":"Reference","previous_headings":"","what":"Active bindings","title":"Sampler1D Class — Sampler1D","text":"param (ParamSet) Returns one-dimensional ParamSet sampled .","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1D.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Sampler1D Class — Sampler1D","text":"paradox::Sampler$format() paradox::Sampler$print() paradox::Sampler$sample()","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1D.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Sampler1D Class — Sampler1D","text":"Sampler1D$new() Sampler1D$clone()","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1D.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Sampler1D Class — Sampler1D","text":"Creates new instance R6 class. Note object typically constructed via derived classes, e.g., Sampler1DUnif.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1D.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sampler1D Class — Sampler1D","text":"","code":"Sampler1D$new(param)"},{"path":"https://paradox.mlr-org.com/reference/Sampler1D.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sampler1D Class — Sampler1D","text":"param (ParamSet) Domain / support distribution want sample . Must one-dimensional.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1D.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Sampler1D Class — Sampler1D","text":"objects class cloneable method.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1D.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Sampler1D Class — Sampler1D","text":"","code":"Sampler1D$clone(deep = FALSE)"},{"path":"https://paradox.mlr-org.com/reference/Sampler1D.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sampler1D Class — Sampler1D","text":"deep Whether make deep clone.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DCateg.html","id":null,"dir":"Reference","previous_headings":"","what":"Sampler1DCateg Class — Sampler1DCateg","title":"Sampler1DCateg Class — Sampler1DCateg","text":"Sampling discrete distribution, ParamSet containing single p_fct() p_lgl().","code":""},{"path":[]},{"path":"https://paradox.mlr-org.com/reference/Sampler1DCateg.html","id":"super-classes","dir":"Reference","previous_headings":"","what":"Super classes","title":"Sampler1DCateg Class — Sampler1DCateg","text":"paradox::Sampler -> paradox::Sampler1D -> Sampler1DCateg","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DCateg.html","id":"public-fields","dir":"Reference","previous_headings":"","what":"Public fields","title":"Sampler1DCateg Class — Sampler1DCateg","text":"prob (numeric() | NULL) Numeric vector param$nlevels probabilities.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DCateg.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Sampler1DCateg Class — Sampler1DCateg","text":"paradox::Sampler$format() paradox::Sampler$print() paradox::Sampler$sample()","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DCateg.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Sampler1DCateg Class — Sampler1DCateg","text":"Sampler1DCateg$new() Sampler1DCateg$clone()","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DCateg.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Sampler1DCateg Class — Sampler1DCateg","text":"Creates new instance R6 class.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DCateg.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sampler1DCateg Class — Sampler1DCateg","text":"","code":"Sampler1DCateg$new(param, prob = NULL)"},{"path":"https://paradox.mlr-org.com/reference/Sampler1DCateg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sampler1DCateg Class — Sampler1DCateg","text":"param (ParamSet) Domain / support distribution want sample . Must one-dimensional. prob (numeric() | NULL) Numeric vector param$nlevels probabilities, uniform default.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DCateg.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Sampler1DCateg Class — Sampler1DCateg","text":"objects class cloneable method.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DCateg.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Sampler1DCateg Class — Sampler1DCateg","text":"","code":"Sampler1DCateg$clone(deep = FALSE)"},{"path":"https://paradox.mlr-org.com/reference/Sampler1DCateg.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sampler1DCateg Class — Sampler1DCateg","text":"deep Whether make deep clone.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DNormal.html","id":null,"dir":"Reference","previous_headings":"","what":"Sampler1DNormal Class — Sampler1DNormal","title":"Sampler1DNormal Class — Sampler1DNormal","text":"Normal sampling (potentially truncated) p_dbl().","code":""},{"path":[]},{"path":"https://paradox.mlr-org.com/reference/Sampler1DNormal.html","id":"super-classes","dir":"Reference","previous_headings":"","what":"Super classes","title":"Sampler1DNormal Class — Sampler1DNormal","text":"paradox::Sampler -> paradox::Sampler1D -> paradox::Sampler1DRfun -> Sampler1DNormal","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DNormal.html","id":"active-bindings","dir":"Reference","previous_headings":"","what":"Active bindings","title":"Sampler1DNormal Class — Sampler1DNormal","text":"mean (numeric(1)) Mean parameter normal distribution. sd (numeric(1)) SD parameter normal distribution.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DNormal.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Sampler1DNormal Class — Sampler1DNormal","text":"paradox::Sampler$format() paradox::Sampler$print() paradox::Sampler$sample()","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DNormal.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Sampler1DNormal Class — Sampler1DNormal","text":"Sampler1DNormal$new() Sampler1DNormal$clone()","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DNormal.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Sampler1DNormal Class — Sampler1DNormal","text":"Creates new instance R6 class.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DNormal.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sampler1DNormal Class — Sampler1DNormal","text":"","code":"Sampler1DNormal$new(param, mean = NULL, sd = NULL)"},{"path":"https://paradox.mlr-org.com/reference/Sampler1DNormal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sampler1DNormal Class — Sampler1DNormal","text":"param (ParamSet) Domain / support distribution want sample . Must one-dimensional. mean (numeric(1)) Mean parameter normal distribution. Default mean(c(param$lower, param$upper). sd (numeric(1)) SD parameter normal distribution. Default (param$upper - param$lower)/4.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DNormal.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Sampler1DNormal Class — Sampler1DNormal","text":"objects class cloneable method.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DNormal.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Sampler1DNormal Class — Sampler1DNormal","text":"","code":"Sampler1DNormal$clone(deep = FALSE)"},{"path":"https://paradox.mlr-org.com/reference/Sampler1DNormal.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sampler1DNormal Class — Sampler1DNormal","text":"deep Whether make deep clone.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DRfun.html","id":null,"dir":"Reference","previous_headings":"","what":"Sampler1DRfun Class — Sampler1DRfun","title":"Sampler1DRfun Class — Sampler1DRfun","text":"Arbitrary sampling 1D RNG functions R.","code":""},{"path":[]},{"path":"https://paradox.mlr-org.com/reference/Sampler1DRfun.html","id":"super-classes","dir":"Reference","previous_headings":"","what":"Super classes","title":"Sampler1DRfun Class — Sampler1DRfun","text":"paradox::Sampler -> paradox::Sampler1D -> Sampler1DRfun","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DRfun.html","id":"public-fields","dir":"Reference","previous_headings":"","what":"Public fields","title":"Sampler1DRfun Class — Sampler1DRfun","text":"rfun (function()) Random number generator function. trunc (logical(1))TRUE enables naive rejection sampling, stay inside [lower, upper].","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DRfun.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Sampler1DRfun Class — Sampler1DRfun","text":"paradox::Sampler$format() paradox::Sampler$print() paradox::Sampler$sample()","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DRfun.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Sampler1DRfun Class — Sampler1DRfun","text":"Sampler1DRfun$new() Sampler1DRfun$clone()","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DRfun.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Sampler1DRfun Class — Sampler1DRfun","text":"Creates new instance R6 class.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DRfun.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sampler1DRfun Class — Sampler1DRfun","text":"","code":"Sampler1DRfun$new(param, rfun, trunc = TRUE)"},{"path":"https://paradox.mlr-org.com/reference/Sampler1DRfun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sampler1DRfun Class — Sampler1DRfun","text":"param (ParamSet) Domain / support distribution want sample . Must one-dimensional. rfun (function()) Random number generator function, e.g. rexp sample exponential distribution. trunc (logical(1))TRUE enables naive rejection sampling, stay inside [lower, upper].","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DRfun.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Sampler1DRfun Class — Sampler1DRfun","text":"objects class cloneable method.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DRfun.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Sampler1DRfun Class — Sampler1DRfun","text":"","code":"Sampler1DRfun$clone(deep = FALSE)"},{"path":"https://paradox.mlr-org.com/reference/Sampler1DRfun.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sampler1DRfun Class — Sampler1DRfun","text":"deep Whether make deep clone.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DUnif.html","id":null,"dir":"Reference","previous_headings":"","what":"Sampler1DUnif Class — Sampler1DUnif","title":"Sampler1DUnif Class — Sampler1DUnif","text":"Uniform random sampler arbitrary (bounded) parameters.","code":""},{"path":[]},{"path":"https://paradox.mlr-org.com/reference/Sampler1DUnif.html","id":"super-classes","dir":"Reference","previous_headings":"","what":"Super classes","title":"Sampler1DUnif Class — Sampler1DUnif","text":"paradox::Sampler -> paradox::Sampler1D -> Sampler1DUnif","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DUnif.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Sampler1DUnif Class — Sampler1DUnif","text":"paradox::Sampler$format() paradox::Sampler$print() paradox::Sampler$sample()","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DUnif.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Sampler1DUnif Class — Sampler1DUnif","text":"Sampler1DUnif$new() Sampler1DUnif$clone()","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DUnif.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Sampler1DUnif Class — Sampler1DUnif","text":"Creates new instance R6 class.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DUnif.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sampler1DUnif Class — Sampler1DUnif","text":"","code":"Sampler1DUnif$new(param)"},{"path":"https://paradox.mlr-org.com/reference/Sampler1DUnif.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sampler1DUnif Class — Sampler1DUnif","text":"param (ParamSet) Domain / support distribution want sample . Must one-dimensional.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DUnif.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Sampler1DUnif Class — Sampler1DUnif","text":"objects class cloneable method.","code":""},{"path":"https://paradox.mlr-org.com/reference/Sampler1DUnif.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Sampler1DUnif Class — Sampler1DUnif","text":"","code":"Sampler1DUnif$clone(deep = FALSE)"},{"path":"https://paradox.mlr-org.com/reference/Sampler1DUnif.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sampler1DUnif Class — Sampler1DUnif","text":"deep Whether make deep clone.","code":""},{"path":"https://paradox.mlr-org.com/reference/SamplerHierarchical.html","id":null,"dir":"Reference","previous_headings":"","what":"SamplerHierarchical Class — SamplerHierarchical","title":"SamplerHierarchical Class — SamplerHierarchical","text":"Hierarchical sampling arbitrary param sets dependencies, user specifies 1D samplers per param. Dependencies topologically sorted, parameters sampled topological order, dependencies hold, values set NA resulting data.table.","code":""},{"path":[]},{"path":"https://paradox.mlr-org.com/reference/SamplerHierarchical.html","id":"super-class","dir":"Reference","previous_headings":"","what":"Super class","title":"SamplerHierarchical Class — SamplerHierarchical","text":"paradox::Sampler -> SamplerHierarchical","code":""},{"path":"https://paradox.mlr-org.com/reference/SamplerHierarchical.html","id":"public-fields","dir":"Reference","previous_headings":"","what":"Public fields","title":"SamplerHierarchical Class — SamplerHierarchical","text":"samplers (list()) List Sampler1D objects gives Sampler dimension param_set.","code":""},{"path":"https://paradox.mlr-org.com/reference/SamplerHierarchical.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"SamplerHierarchical Class — SamplerHierarchical","text":"paradox::Sampler$format() paradox::Sampler$print() paradox::Sampler$sample()","code":""},{"path":"https://paradox.mlr-org.com/reference/SamplerHierarchical.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"SamplerHierarchical Class — SamplerHierarchical","text":"SamplerHierarchical$new() SamplerHierarchical$clone()","code":""},{"path":"https://paradox.mlr-org.com/reference/SamplerHierarchical.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"SamplerHierarchical Class — SamplerHierarchical","text":"Creates new instance R6 class.","code":""},{"path":"https://paradox.mlr-org.com/reference/SamplerHierarchical.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SamplerHierarchical Class — SamplerHierarchical","text":"","code":"SamplerHierarchical$new(param_set, samplers)"},{"path":"https://paradox.mlr-org.com/reference/SamplerHierarchical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SamplerHierarchical Class — SamplerHierarchical","text":"param_set (ParamSet) ParamSet associated SamplerHierarchical. samplers (list()) List Sampler1D objects gives Sampler dimension param_set.","code":""},{"path":"https://paradox.mlr-org.com/reference/SamplerHierarchical.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"SamplerHierarchical Class — SamplerHierarchical","text":"objects class cloneable method.","code":""},{"path":"https://paradox.mlr-org.com/reference/SamplerHierarchical.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"SamplerHierarchical Class — SamplerHierarchical","text":"","code":"SamplerHierarchical$clone(deep = FALSE)"},{"path":"https://paradox.mlr-org.com/reference/SamplerHierarchical.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"SamplerHierarchical Class — SamplerHierarchical","text":"deep Whether make deep clone.","code":""},{"path":"https://paradox.mlr-org.com/reference/SamplerJointIndep.html","id":null,"dir":"Reference","previous_headings":"","what":"SamplerJointIndep Class — SamplerJointIndep","title":"SamplerJointIndep Class — SamplerJointIndep","text":"Create joint, independent sampler multiple samplers.","code":""},{"path":[]},{"path":"https://paradox.mlr-org.com/reference/SamplerJointIndep.html","id":"super-class","dir":"Reference","previous_headings":"","what":"Super class","title":"SamplerJointIndep Class — SamplerJointIndep","text":"paradox::Sampler -> SamplerJointIndep","code":""},{"path":"https://paradox.mlr-org.com/reference/SamplerJointIndep.html","id":"public-fields","dir":"Reference","previous_headings":"","what":"Public fields","title":"SamplerJointIndep Class — SamplerJointIndep","text":"samplers (list()) List Sampler objects.","code":""},{"path":"https://paradox.mlr-org.com/reference/SamplerJointIndep.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"SamplerJointIndep Class — SamplerJointIndep","text":"paradox::Sampler$format() paradox::Sampler$print() paradox::Sampler$sample()","code":""},{"path":"https://paradox.mlr-org.com/reference/SamplerJointIndep.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"SamplerJointIndep Class — SamplerJointIndep","text":"SamplerJointIndep$new() SamplerJointIndep$clone()","code":""},{"path":"https://paradox.mlr-org.com/reference/SamplerJointIndep.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"SamplerJointIndep Class — SamplerJointIndep","text":"Creates new instance R6 class.","code":""},{"path":"https://paradox.mlr-org.com/reference/SamplerJointIndep.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SamplerJointIndep Class — SamplerJointIndep","text":"","code":"SamplerJointIndep$new(samplers)"},{"path":"https://paradox.mlr-org.com/reference/SamplerJointIndep.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SamplerJointIndep Class — SamplerJointIndep","text":"samplers (list()) List Sampler objects.","code":""},{"path":"https://paradox.mlr-org.com/reference/SamplerJointIndep.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"SamplerJointIndep Class — SamplerJointIndep","text":"objects class cloneable method.","code":""},{"path":"https://paradox.mlr-org.com/reference/SamplerJointIndep.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"SamplerJointIndep Class — SamplerJointIndep","text":"","code":"SamplerJointIndep$clone(deep = FALSE)"},{"path":"https://paradox.mlr-org.com/reference/SamplerJointIndep.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"SamplerJointIndep Class — SamplerJointIndep","text":"deep Whether make deep clone.","code":""},{"path":"https://paradox.mlr-org.com/reference/SamplerUnif.html","id":null,"dir":"Reference","previous_headings":"","what":"SamplerUnif Class — SamplerUnif","title":"SamplerUnif Class — SamplerUnif","text":"Uniform random sampling arbitrary (bounded) ParamSet. Constructs 1 uniform sampler per parameter, passes SamplerHierarchical. Hence, also works ParamSets sets dependencies.","code":""},{"path":[]},{"path":"https://paradox.mlr-org.com/reference/SamplerUnif.html","id":"super-classes","dir":"Reference","previous_headings":"","what":"Super classes","title":"SamplerUnif Class — SamplerUnif","text":"paradox::Sampler -> paradox::SamplerHierarchical -> SamplerUnif","code":""},{"path":"https://paradox.mlr-org.com/reference/SamplerUnif.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"SamplerUnif Class — SamplerUnif","text":"paradox::Sampler$format() paradox::Sampler$print() paradox::Sampler$sample()","code":""},{"path":"https://paradox.mlr-org.com/reference/SamplerUnif.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"SamplerUnif Class — SamplerUnif","text":"SamplerUnif$new() SamplerUnif$clone()","code":""},{"path":"https://paradox.mlr-org.com/reference/SamplerUnif.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"SamplerUnif Class — SamplerUnif","text":"Creates new instance R6 class.","code":""},{"path":"https://paradox.mlr-org.com/reference/SamplerUnif.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SamplerUnif Class — SamplerUnif","text":"","code":"SamplerUnif$new(param_set)"},{"path":"https://paradox.mlr-org.com/reference/SamplerUnif.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SamplerUnif Class — SamplerUnif","text":"param_set (ParamSet) ParamSet associated SamplerUnif.","code":""},{"path":"https://paradox.mlr-org.com/reference/SamplerUnif.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"SamplerUnif Class — SamplerUnif","text":"objects class cloneable method.","code":""},{"path":"https://paradox.mlr-org.com/reference/SamplerUnif.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"SamplerUnif Class — SamplerUnif","text":"","code":"SamplerUnif$clone(deep = FALSE)"},{"path":"https://paradox.mlr-org.com/reference/SamplerUnif.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"SamplerUnif Class — SamplerUnif","text":"deep Whether make deep clone.","code":""},{"path":"https://paradox.mlr-org.com/reference/assert_param_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Assertions for Params and ParamSets — assert_param_set","title":"Assertions for Params and ParamSets — assert_param_set","text":"Assertions Params ParamSets","code":""},{"path":"https://paradox.mlr-org.com/reference/assert_param_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assertions for Params and ParamSets — assert_param_set","text":"","code":"assert_param_set(   param_set,   cl = NULL,   no_untyped = FALSE,   must_bounded = FALSE,   no_deps = FALSE )"},{"path":"https://paradox.mlr-org.com/reference/assert_param_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assertions for Params and ParamSets — assert_param_set","text":"param_set (ParamSet). cl (character()) Allowed subclasses. no_untyped (logical(1)) untyped Domains allowed? must_bounded (logical(1)) bounded Domains allowed? no_deps (logical(1)) dependencies allowed?","code":""},{"path":"https://paradox.mlr-org.com/reference/assert_param_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assertions for Params and ParamSets — assert_param_set","text":"checked object, invisibly.","code":""},{"path":"https://paradox.mlr-org.com/reference/default_values.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Parameter Default Values — default_values","title":"Extract Parameter Default Values — default_values","text":"Extract parameter default values.","code":""},{"path":"https://paradox.mlr-org.com/reference/default_values.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Parameter Default Values — default_values","text":"","code":"default_values(x, ...)  # S3 method for ParamSet default_values(x, ...)"},{"path":"https://paradox.mlr-org.com/reference/default_values.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Parameter Default Values — default_values","text":"x () Object extract default values . ... () Additional arguments.","code":""},{"path":"https://paradox.mlr-org.com/reference/default_values.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Parameter Default Values — default_values","text":"list().","code":""},{"path":"https://paradox.mlr-org.com/reference/domain_check.html","id":null,"dir":"Reference","previous_headings":"","what":"Check Value Validity — domain_check","title":"Check Value Validity — domain_check","text":"checkmate-like check-function. Check whether list values feasible domain. value feasible storage_type, inside bounds element special_vals. TuneTokens generally accepted, filtered call, present. domain_check return TRUE accepted values, character(1) error message otherwise. domain_test return TRUE accepted values, FALSE otherwise. domain_assert return param argument silently accepted values, throw error message otherwise.","code":""},{"path":"https://paradox.mlr-org.com/reference/domain_check.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check Value Validity — domain_check","text":"","code":"domain_check(param, values)  domain_assert(param, values, .var.name = checkmate::vname(param), add = NULL)  domain_test(param, values)"},{"path":"https://paradox.mlr-org.com/reference/domain_check.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check Value Validity — domain_check","text":"param (Domain). values ().","code":""},{"path":"https://paradox.mlr-org.com/reference/domain_check.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check Value Validity — domain_check","text":"successful TRUE, string error message.","code":""},{"path":"https://paradox.mlr-org.com/reference/domain_is_bounded.html","id":null,"dir":"Reference","previous_headings":"","what":"Whether a Given Domain is Bounded — domain_is_bounded","title":"Whether a Given Domain is Bounded — domain_is_bounded","text":"generally TRUE lower upper given finite, nlevels finite, FALSE otherwise.","code":""},{"path":"https://paradox.mlr-org.com/reference/domain_is_bounded.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Whether a Given Domain is Bounded — domain_is_bounded","text":"","code":"domain_is_bounded(param)"},{"path":"https://paradox.mlr-org.com/reference/domain_is_bounded.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Whether a Given Domain is Bounded — domain_is_bounded","text":"param (Domain).","code":""},{"path":"https://paradox.mlr-org.com/reference/domain_is_bounded.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Whether a Given Domain is Bounded — domain_is_bounded","text":"logical.","code":""},{"path":"https://paradox.mlr-org.com/reference/domain_is_categ.html","id":null,"dir":"Reference","previous_headings":"","what":"Whether a Given Domain is Categorical — domain_is_categ","title":"Whether a Given Domain is Categorical — domain_is_categ","text":"generally TRUE categorical Domains, p_fct() p_lgl(), FALSE otherwise.","code":""},{"path":"https://paradox.mlr-org.com/reference/domain_is_categ.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Whether a Given Domain is Categorical — domain_is_categ","text":"","code":"domain_is_categ(param)"},{"path":"https://paradox.mlr-org.com/reference/domain_is_categ.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Whether a Given Domain is Categorical — domain_is_categ","text":"param (Domain).","code":""},{"path":"https://paradox.mlr-org.com/reference/domain_is_categ.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Whether a Given Domain is Categorical — domain_is_categ","text":"logical.","code":""},{"path":"https://paradox.mlr-org.com/reference/domain_is_number.html","id":null,"dir":"Reference","previous_headings":"","what":"Whether a Given Domain is Numeric — domain_is_number","title":"Whether a Given Domain is Numeric — domain_is_number","text":"generally TRUE discrete continuous numeric Domains, FALSE otherwise.","code":""},{"path":"https://paradox.mlr-org.com/reference/domain_is_number.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Whether a Given Domain is Numeric — domain_is_number","text":"","code":"domain_is_number(param)"},{"path":"https://paradox.mlr-org.com/reference/domain_is_number.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Whether a Given Domain is Numeric — domain_is_number","text":"param (Domain).","code":""},{"path":"https://paradox.mlr-org.com/reference/domain_is_number.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Whether a Given Domain is Numeric — domain_is_number","text":"logical.","code":""},{"path":"https://paradox.mlr-org.com/reference/domain_nlevels.html","id":null,"dir":"Reference","previous_headings":"","what":"The Number of Levels of a Given Domain — domain_nlevels","title":"The Number of Levels of a Given Domain — domain_nlevels","text":"number discrete possible levels discrete type Domains p_int() p_fct(), Inf continuous untyped parameters.","code":""},{"path":"https://paradox.mlr-org.com/reference/domain_nlevels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Number of Levels of a Given Domain — domain_nlevels","text":"","code":"domain_nlevels(param)"},{"path":"https://paradox.mlr-org.com/reference/domain_nlevels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Number of Levels of a Given Domain — domain_nlevels","text":"param (Domain).","code":""},{"path":"https://paradox.mlr-org.com/reference/domain_nlevels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Number of Levels of a Given Domain — domain_nlevels","text":"numeric.","code":""},{"path":"https://paradox.mlr-org.com/reference/domain_qunif.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform a Numeric Value to a Sample — domain_qunif","title":"Transform a Numeric Value to a Sample — domain_qunif","text":"Return valid sample given Domain, given value interval [0, 1].","code":""},{"path":"https://paradox.mlr-org.com/reference/domain_qunif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform a Numeric Value to a Sample — domain_qunif","text":"","code":"domain_qunif(param, x)"},{"path":"https://paradox.mlr-org.com/reference/domain_qunif.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform a Numeric Value to a Sample — domain_qunif","text":"param (Domain). x numeric 0 1.","code":""},{"path":"https://paradox.mlr-org.com/reference/domain_qunif.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform a Numeric Value to a Sample — domain_qunif","text":"-- format depending Domain.","code":""},{"path":"https://paradox.mlr-org.com/reference/domain_sanitize.html","id":null,"dir":"Reference","previous_headings":"","what":"Map to Acceptable Value — domain_sanitize","title":"Map to Acceptable Value — domain_sanitize","text":"Map values close enough given Domain values truly acceptable. used map numeric() values close outside acceptable interval interval bounds. also used convert integer-valued numeric values integer values p_int().","code":""},{"path":"https://paradox.mlr-org.com/reference/domain_sanitize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map to Acceptable Value — domain_sanitize","text":"","code":"domain_sanitize(param, values)"},{"path":"https://paradox.mlr-org.com/reference/domain_sanitize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map to Acceptable Value — domain_sanitize","text":"param (Domain). values () -- format depending Domain.","code":""},{"path":"https://paradox.mlr-org.com/reference/domain_sanitize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map to Acceptable Value — domain_sanitize","text":"-- format depending Domain.","code":""},{"path":"https://paradox.mlr-org.com/reference/generate_design_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a Grid Design — generate_design_grid","title":"Generate a Grid Design — generate_design_grid","text":"Generate grid specified resolution parameter space. resolution categorical parameters ignored, parameters always produce grid valid levels. number params endpoints params always included grid.","code":""},{"path":"https://paradox.mlr-org.com/reference/generate_design_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a Grid Design — generate_design_grid","text":"","code":"generate_design_grid(param_set, resolution = NULL, param_resolutions = NULL)"},{"path":"https://paradox.mlr-org.com/reference/generate_design_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a Grid Design — generate_design_grid","text":"param_set (ParamSet). resolution (integer(1)) Global resolution parameters. param_resolutions (named integer()) Resolution per Domain, named parameter ID.","code":""},{"path":"https://paradox.mlr-org.com/reference/generate_design_grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a Grid Design — generate_design_grid","text":"Design.","code":""},{"path":[]},{"path":"https://paradox.mlr-org.com/reference/generate_design_grid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a Grid Design — generate_design_grid","text":"","code":"pset = ps(   ratio = p_dbl(lower = 0, upper = 1),   letters = p_fct(levels = letters[1:3]) ) generate_design_grid(pset, 10) #> <Design> with 30 rows: #>         ratio letters #>         <num>  <char> #>  1: 0.0000000       a #>  2: 0.0000000       b #>  3: 0.0000000       c #>  4: 0.1111111       a #>  5: 0.1111111       b #>  6: 0.1111111       c #>  7: 0.2222222       a #>  8: 0.2222222       b #>  9: 0.2222222       c #> 10: 0.3333333       a #> 11: 0.3333333       b #> 12: 0.3333333       c #> 13: 0.4444444       a #> 14: 0.4444444       b #> 15: 0.4444444       c #> 16: 0.5555556       a #> 17: 0.5555556       b #> 18: 0.5555556       c #> 19: 0.6666667       a #> 20: 0.6666667       b #> 21: 0.6666667       c #> 22: 0.7777778       a #> 23: 0.7777778       b #> 24: 0.7777778       c #> 25: 0.8888889       a #> 26: 0.8888889       b #> 27: 0.8888889       c #> 28: 1.0000000       a #> 29: 1.0000000       b #> 30: 1.0000000       c #>         ratio letters"},{"path":"https://paradox.mlr-org.com/reference/generate_design_lhs.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a Space-Filling LHS Design — generate_design_lhs","title":"Generate a Space-Filling LHS Design — generate_design_lhs","text":"Generate space-filling design using Latin hypercube sampling. Dependent parameters whose constraints unsatisfied generate NA entries respective columns.","code":""},{"path":"https://paradox.mlr-org.com/reference/generate_design_lhs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a Space-Filling LHS Design — generate_design_lhs","text":"","code":"generate_design_lhs(param_set, n, lhs_fun = NULL)"},{"path":"https://paradox.mlr-org.com/reference/generate_design_lhs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a Space-Filling LHS Design — generate_design_lhs","text":"param_set (ParamSet). n (integer(1))  Number points sample. lhs_fun (function(n, k)) Function use generate LHS sample, n samples k values per param. LHS functions implemented package lhs, default use lhs::maximinLHS().","code":""},{"path":"https://paradox.mlr-org.com/reference/generate_design_lhs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a Space-Filling LHS Design — generate_design_lhs","text":"Design.","code":""},{"path":[]},{"path":"https://paradox.mlr-org.com/reference/generate_design_lhs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a Space-Filling LHS Design — generate_design_lhs","text":"","code":"pset = ps(   ratio = p_dbl(lower = 0, upper = 1),   letters = p_fct(levels = letters[1:3]) )  if (requireNamespace(\"lhs\", quietly = TRUE)) {   generate_design_lhs(pset, 10) } #> <Design> with 10 rows: #>          ratio letters #>          <num>  <char> #>  1: 0.34039110       a #>  2: 0.52184310       b #>  3: 0.74183614       c #>  4: 0.46688707       b #>  5: 0.25076503       a #>  6: 0.66603593       c #>  7: 0.05117913       b #>  8: 0.98355524       c #>  9: 0.17087812       c #> 10: 0.88742059       a"},{"path":"https://paradox.mlr-org.com/reference/generate_design_random.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a Random Design — generate_design_random","title":"Generate a Random Design — generate_design_random","text":"Generates design randomly drawn points. Internally uses SamplerUnif, hence, also works ParamSets dependencies. dependencies hold, values set NA resulting data.table.","code":""},{"path":"https://paradox.mlr-org.com/reference/generate_design_random.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a Random Design — generate_design_random","text":"","code":"generate_design_random(param_set, n)"},{"path":"https://paradox.mlr-org.com/reference/generate_design_random.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a Random Design — generate_design_random","text":"param_set (ParamSet). n (integer(1)) Number points draw randomly.","code":""},{"path":"https://paradox.mlr-org.com/reference/generate_design_random.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a Random Design — generate_design_random","text":"Design.","code":""},{"path":[]},{"path":"https://paradox.mlr-org.com/reference/generate_design_random.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a Random Design — generate_design_random","text":"","code":"pset = ps(   ratio = p_dbl(lower = 0, upper = 1),   letters = p_fct(levels = letters[1:3]) ) generate_design_random(pset, 10) #> <Design> with 10 rows: #>         ratio letters #>         <num>  <char> #>  1: 0.2529970       c #>  2: 0.9188032       c #>  3: 0.8673502       b #>  4: 0.2485387       b #>  5: 0.4028812       c #>  6: 0.7696302       a #>  7: 0.1194854       a #>  8: 0.1946950       c #>  9: 0.1645692       a #> 10: 0.6632066       c"},{"path":"https://paradox.mlr-org.com/reference/generate_design_sobol.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a Space-Filling Sobol Sequence Design — generate_design_sobol","title":"Generate a Space-Filling Sobol Sequence Design — generate_design_sobol","text":"Generate space-filling design using Sobol sequence. Dependent parameters whose constraints unsatisfied generate NA entries respective columns. Uses spacefillr::generate_sobol_set. Note non determinism achieved sampling seed argument via sample(.Machine$integer.max, size = 1L).","code":""},{"path":"https://paradox.mlr-org.com/reference/generate_design_sobol.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a Space-Filling Sobol Sequence Design — generate_design_sobol","text":"","code":"generate_design_sobol(param_set, n)"},{"path":"https://paradox.mlr-org.com/reference/generate_design_sobol.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a Space-Filling Sobol Sequence Design — generate_design_sobol","text":"param_set (ParamSet). n (integer(1))  Number points sample.","code":""},{"path":"https://paradox.mlr-org.com/reference/generate_design_sobol.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a Space-Filling Sobol Sequence Design — generate_design_sobol","text":"Design.","code":""},{"path":[]},{"path":"https://paradox.mlr-org.com/reference/generate_design_sobol.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a Space-Filling Sobol Sequence Design — generate_design_sobol","text":"","code":"pset = ps(   ratio = p_dbl(lower = 0, upper = 1),   letters = p_fct(levels = letters[1:3]) )  if (requireNamespace(\"spacefillr\", quietly = TRUE)) {   generate_design_sobol(pset, 10) } #> <Design> with 10 rows: #>          ratio letters #>          <num>  <char> #>  1: 0.52322876       b #>  2: 0.02322876       c #>  3: 0.77322876       b #>  4: 0.27322876       a #>  5: 0.14822876       b #>  6: 0.64822876       c #>  7: 0.39822876       c #>  8: 0.89822876       a #>  9: 0.58572876       c #> 10: 0.08572876       a"},{"path":"https://paradox.mlr-org.com/reference/paradox-package.html","id":null,"dir":"Reference","previous_headings":"","what":"paradox: Define and Work with Parameter Spaces for Complex Algorithms — paradox-package","title":"paradox: Define and Work with Parameter Spaces for Complex Algorithms — paradox-package","text":"Define parameter spaces, constraints dependencies arbitrary algorithms, program spaces. Also includes statistical designs random samplers. Objects implemented 'R6' classes.","code":""},{"path":[]},{"path":"https://paradox.mlr-org.com/reference/paradox-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"paradox: Define and Work with Parameter Spaces for Complex Algorithms — paradox-package","text":"Maintainer: Martin Binder mlr.developer@mb706.com Authors: Michel Lang michellang@gmail.com (ORCID) Bernd Bischl bernd_bischl@gmx.net (ORCID) Jakob Richter jakob1richter@gmail.com (ORCID) Xudong Sun smilesun.east@gmail.com (ORCID) contributors: Marc Becker marcbecker@posteo.de (ORCID) [contributor]","code":""},{"path":"https://paradox.mlr-org.com/reference/ps.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a ParamSet using Short Forms — ps","title":"Construct a ParamSet using Short Forms — ps","text":"ps() short form constructor uses Domain objects (p_dbl, p_fct, ...) construct ParamSets succinct readable way. specifics also see documentation Domain.","code":""},{"path":"https://paradox.mlr-org.com/reference/ps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a ParamSet using Short Forms — ps","text":"","code":"ps(   ...,   .extra_trafo = NULL,   .constraint = NULL,   .allow_dangling_dependencies = FALSE )"},{"path":"https://paradox.mlr-org.com/reference/ps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a ParamSet using Short Forms — ps","text":"... (Domain) Named arguments Domain objects. ParamSet constructed given Domains, names arguments used $id() resulting ParamSet. .extra_trafo (function(x, param_set)) Transformation set resulting ParamSet's $trafo value . addition trafo Domain objects given ..., run transformations individual parameters performed. .constraint (function(x)) Constraint function. given, function must evaluate named list() values determine whether satisfies constraints, returning scalar logical(1) value. .allow_dangling_dependencies (logical) Whether dependencies depending parameters present allowed. parameter x depends = y == 0 y present ps() call usually throw error, dangling dependencies allowed, dependency added regardless. usually bad idea mainly internal use. Dependencies ParamSets using to_tune() can realized using .","code":""},{"path":"https://paradox.mlr-org.com/reference/ps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct a ParamSet using Short Forms — ps","text":"ParamSet object.","code":""},{"path":[]},{"path":"https://paradox.mlr-org.com/reference/ps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct a ParamSet using Short Forms — ps","text":"","code":"pars = ps(   a = p_int(0, 10),   b = p_int(upper = 20),   c = p_dbl(),   e = p_fct(letters[1:3]),   f = p_uty(custom_check = checkmate::check_function) ) print(pars) #> <ParamSet(5)> #>        id    class lower upper nlevels        default  value #>    <char>   <char> <num> <num>   <num>         <list> <list> #> 1:      a ParamInt     0    10      11 <NoDefault[0]>        #> 2:      b ParamInt  -Inf    20     Inf <NoDefault[0]>        #> 3:      c ParamDbl  -Inf   Inf     Inf <NoDefault[0]>        #> 4:      e ParamFct    NA    NA       3 <NoDefault[0]>        #> 5:      f ParamUty    NA    NA     Inf <NoDefault[0]>         pars = ps(   a = p_dbl(0, 1, trafo = exp),   b = p_dbl(0, 1, trafo = exp),   .extra_trafo = function(x, ps) {     x$c <- x$a + x$b     x   } )  # See how the addition happens after exp()ing: pars$trafo(list(a = 0, b = 0)) #> $a #> [1] 1 #>  #> $b #> [1] 1 #>  #> $c #> [1] 2 #>   pars$values = list(   a = to_tune(ps(x = p_int(0, 1),     .extra_trafo = function(x, param_set) list(a = x$x)   )),   # make 'y' depend on 'x', but they are defined in different ParamSets   # Therefore we need to allow dangling dependencies here.   b = to_tune(ps(y = p_int(0, 1, depends = x == 1),     .extra_trafo = function(x, param_set) list(b = x$y),     .allow_dangling_dependencies = TRUE   )) )  pars$search_space() #> <ParamSet(2)> #> Key: <id> #>        id    class lower upper nlevels        default parents  value #>    <char>   <char> <num> <num>   <num>         <list>  <list> <list> #> 1:      x ParamInt     0     1       2 <NoDefault[0]>                #> 2:      y ParamInt     0     1       2 <NoDefault[0]>       x        #> Trafo is set."},{"path":"https://paradox.mlr-org.com/reference/ps_replicate.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a ParamSet by Repeating a Given ParamSet — ps_replicate","title":"Create a ParamSet by Repeating a Given ParamSet — ps_replicate","text":"Repeat ParamSet given number times thus create larger ParamSet. default, resulting parameters prefixed string \"repX.\", Xcounts 1. also possible tag parameters original name prefix, making grouped retrieval e.g. using$get_values()` easier.","code":""},{"path":"https://paradox.mlr-org.com/reference/ps_replicate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a ParamSet by Repeating a Given ParamSet — ps_replicate","text":"","code":"ps_replicate(   set,   times = length(prefixes),   prefixes = sprintf(\"rep%s\", seq_len(times)),   tag_sets = FALSE,   tag_params = FALSE )"},{"path":"https://paradox.mlr-org.com/reference/ps_replicate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a ParamSet by Repeating a Given ParamSet — ps_replicate","text":"set (ParamSet)ParamSet use template. times (integer(1)) Number times repeat set. given prefixes provided. prefixes (character) character vector indicating prefixes use repetition set. given, times inferred length(prefixes) given separately. times given, defaults \"repX\", X counting 1. tag_sets (logical(1)) Whether add tag form \"set_<prefixes[[]]>\" parameter result, indicating repetition parameter belongs . tag_params (logical(1)) Whether add tag form \"param_<id>\" parameter result, indicating original parameter ID inside set.","code":""},{"path":"https://paradox.mlr-org.com/reference/ps_replicate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a ParamSet by Repeating a Given ParamSet — ps_replicate","text":"","code":"pset = ps(   i = p_int(),   z = p_lgl() )  ps_replicate(pset, 3) #> <ParamSet(6)> #>        id    class lower upper nlevels        default  value #>    <char>   <char> <num> <num>   <num>         <list> <list> #> 1: rep1.i ParamInt  -Inf   Inf     Inf <NoDefault[0]>        #> 2: rep1.z ParamLgl    NA    NA       2 <NoDefault[0]>        #> 3: rep2.i ParamInt  -Inf   Inf     Inf <NoDefault[0]>        #> 4: rep2.z ParamLgl    NA    NA       2 <NoDefault[0]>        #> 5: rep3.i ParamInt  -Inf   Inf     Inf <NoDefault[0]>        #> 6: rep3.z ParamLgl    NA    NA       2 <NoDefault[0]>         ps_replicate(pset, prefixes = c(\"first\", \"last\")) #> <ParamSet(4)> #>         id    class lower upper nlevels        default  value #>     <char>   <char> <num> <num>   <num>         <list> <list> #> 1: first.i ParamInt  -Inf   Inf     Inf <NoDefault[0]>        #> 2: first.z ParamLgl    NA    NA       2 <NoDefault[0]>        #> 3:  last.i ParamInt  -Inf   Inf     Inf <NoDefault[0]>        #> 4:  last.z ParamLgl    NA    NA       2 <NoDefault[0]>         pset$values = list(i = 1, z = FALSE)  psr = ps_replicate(pset, 2, tag_sets = TRUE, tag_params = TRUE)  # observe the effect of tag_sets, tag_params: psr$tags #> $rep1.i #> [1] \"set_rep1\" \"param_i\"  #>  #> $rep1.z #> [1] \"set_rep1\" \"param_z\"  #>  #> $rep2.i #> [1] \"set_rep2\" \"param_i\"  #>  #> $rep2.z #> [1] \"set_rep2\" \"param_z\"  #>   # note that values are repeated as well psr$values #> $rep1.i #> [1] 1 #>  #> $rep1.z #> [1] FALSE #>  #> $rep2.i #> [1] 1 #>  #> $rep2.z #> [1] FALSE #>   psr$set_values(rep1.i = 10, rep2.z = TRUE) psr$values #> $rep1.i #> [1] 10 #>  #> $rep1.z #> [1] FALSE #>  #> $rep2.i #> [1] 1 #>  #> $rep2.z #> [1] TRUE #>   # use `any_tags` to get subset of values. # `any_tags = ` is preferable to `tags = `, since parameters # could also have other tags. `tags = ` would require the # selected params to have the given tags exclusively.  # get all values associated with the original parameter `i` psr$get_values(any_tags = \"param_i\") #> $rep1.i #> [1] 10 #>  #> $rep2.i #> [1] 1 #>   # get all values associated with the first repetition \"rep1\" psr$get_values(any_tags = \"set_rep1\") #> $rep1.i #> [1] 10 #>  #> $rep1.z #> [1] FALSE #>"},{"path":"https://paradox.mlr-org.com/reference/ps_union.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a ParamSet from a list of ParamSets — ps_union","title":"Create a ParamSet from a list of ParamSets — ps_union","text":"emulates ParamSetCollection$new(sets), except result flat ParamSet, ParamSetCollection. resulting object decoupled input ParamSet objects: Unlike ParamSetCollection, changing $values resulting object change input ParamSet $values reference. emulates ParamSetCollection$new(sets), particular means resulting ParamSet Domains input sets, $ids changed: ParamSet given sets name, Domains <id> changed <name \"sets\">.<id>. also reflected deps. c() operator, applied ParamSets, synony ps_union().","code":""},{"path":"https://paradox.mlr-org.com/reference/ps_union.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a ParamSet from a list of ParamSets — ps_union","text":"","code":"ps_union(sets, tag_sets = FALSE, tag_params = FALSE)"},{"path":"https://paradox.mlr-org.com/reference/ps_union.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a ParamSet from a list of ParamSets — ps_union","text":"sets (list ParamSet) may named list, case non-empty names prefixed parameters corresponding ParamSet. tag_sets (logical(1)) Whether add tags form \"set_<set_id>\" parameter originating given ParamSet given name <name \"sets\">. tag_params (logical(1)) Whether add tags form \"param_<param_id>\" parameter original ID <param_id>.","code":""},{"path":"https://paradox.mlr-org.com/reference/ps_union.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a ParamSet from a list of ParamSets — ps_union","text":"","code":"ps1 = ps(x = p_dbl()) ps1$values = list(x = 1)  ps2 = ps(y = p_lgl())  pu = ps_union(list(ps1, ps2)) # same as: pu = c(ps1, ps2)  pu #> <ParamSet(2)> #>        id    class lower upper nlevels        default  value #>    <char>   <char> <num> <num>   <num>         <list> <list> #> 1:      x ParamDbl  -Inf   Inf     Inf <NoDefault[0]>      1 #> 2:      y ParamLgl    NA    NA       2 <NoDefault[0]>         pu$values #> $x #> [1] 1 #>   pu$values$x = 2 pu$values #> $x #> [1] 2 #>   # p1 is unchanged: ps1$values #> $x #> [1] 1 #>   # Prefixes automatically created for named elements. # This allows repeating components. pu2 = c(one = ps1, two = ps1, ps2) pu2 #> <ParamSet(3)> #>        id    class lower upper nlevels        default  value #>    <char>   <char> <num> <num>   <num>         <list> <list> #> 1:  one.x ParamDbl  -Inf   Inf     Inf <NoDefault[0]>      1 #> 2:  two.x ParamDbl  -Inf   Inf     Inf <NoDefault[0]>      1 #> 3:      y ParamLgl    NA    NA       2 <NoDefault[0]>         pu2$values #> $one.x #> [1] 1 #>  #> $two.x #> [1] 1 #>"},{"path":"https://paradox.mlr-org.com/reference/psc.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a ParamSet Collection — psc","title":"Create a ParamSet Collection — psc","text":"Creates ParamSetCollection.","code":""},{"path":"https://paradox.mlr-org.com/reference/psc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a ParamSet Collection — psc","text":"","code":"psc(...)"},{"path":"https://paradox.mlr-org.com/reference/psc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a ParamSet Collection — psc","text":"... () ParamSets create collection.","code":""},{"path":"https://paradox.mlr-org.com/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. data.table .data.table","code":""},{"path":"https://paradox.mlr-org.com/reference/to_tune.html","id":null,"dir":"Reference","previous_headings":"","what":"Indicate that a Parameter Value should be Tuned — to_tune","title":"Indicate that a Parameter Value should be Tuned — to_tune","text":"to_tune() creates TuneToken object can assigned $values slot ParamSet alternative concrete value. indicates value given directly tuned using bbotk mlr3tuning. thus parameterized object invoked directly, without wrapped given tuner, give error. tuning range ParamSet constructed TuneToken values ParamSet's $values slot can accessed ParamSet$search_space() method. done automatically tuners tuning range given, also possible access $search_space() method, modify , give modified ParamSet tuning function (anything else , nobody judging ). TuneToken represents range parameter whose $values slot occupies tuned . can constructed via to_tune() function one several ways: to_tune(): Indicates parameter tuned entire range. applies finite parameters (.e. discrete bounded numeric parameters) to_tune(lower, upper, logscale): Indicates numeric parameter tuned inclusive interval spanning lower upper, possibly log scale logscale se TRUE. parameters optional, parameter's lower / upper bounds used without log scale, default. Depending parameter, integer (p_int()) real values (p_dbl()) used.lower, upper, logscale can given position, except one given, case must named disambiguate following cases. logscale TRUE, trafo generated automatically transforms given bounds. bounds log()'d pre-trafo (see examples). See logscale argument Domain functions info. Note \"logscale\" inherited Domain TuneToken belongs ! Defining parameter p_dbl(... logscale = TRUE) automatically give to_tune() assigned log-scale. to_tune(levels): Indicates parameter tuned given discrete values. levels can named unnamed atomic vector list (although unnamed case must possible construct corresponding character vector distinct values using .character). to_tune(<Domain>): given Domain object (constructed e.g. p_int() p_fct()) indicates range tuned . supplied trafo function used parameter transformation. to_tune(<ParamSet>): given ParamSet used tune single dimension. useful cases single evaluation-time parameter value (e.g. p_uty()) constructed multiple tuner-visible parameters (may p_uty()). one-dimensional, supplied ParamSet always contain $extra_trafo function, must always return list single entry. TuneToken object's internals subject change relied upon. TuneToken objects constructed via to_tune(), used giving $values ParamSet.","code":""},{"path":"https://paradox.mlr-org.com/reference/to_tune.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Indicate that a Parameter Value should be Tuned — to_tune","text":"","code":"to_tune(..., internal = !is.null(aggr), aggr = NULL)"},{"path":"https://paradox.mlr-org.com/reference/to_tune.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Indicate that a Parameter Value should be Tuned — to_tune","text":"... given, restricts range tuning , described . internal (logical(1)) Whether create InternalTuneToken. available parameters tagged \"internal_tuning\". aggr (function) Function one argument, list parameter values returns single aggregated value (e.g. mean). specifies multiple parameter values aggregated form single value context internal tuning. none specified, default aggregation function parameter used.","code":""},{"path":"https://paradox.mlr-org.com/reference/to_tune.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Indicate that a Parameter Value should be Tuned — to_tune","text":"TuneToken object.","code":""},{"path":[]},{"path":"https://paradox.mlr-org.com/reference/to_tune.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Indicate that a Parameter Value should be Tuned — to_tune","text":"","code":"params = ps(   int = p_int(0, 10),   int_unbounded = p_int(),   dbl = p_dbl(0, 10),   dbl_unbounded = p_dbl(),   dbl_bounded_below = p_dbl(lower = 1),   fct = p_fct(c(\"a\", \"b\", \"c\")),   uty1 = p_uty(),   uty2 = p_uty(),   uty3 = p_uty(),   uty4 = p_uty(),   uty5 = p_uty() )  params$values = list(    # tune over entire range of `int`, 0..10:   int = to_tune(),    # tune over 2..7:   int_unbounded = to_tune(2, 7),    # tune on a log scale in range 1..10;   # recognize upper bound of 10 automatically, but restrict lower bound to 1:   dbl = to_tune(lower = 1, logscale = TRUE),   ## This is equivalent to the following:   # dbl = to_tune(p_dbl(log(1), log(10), trafo = exp)),    # nothing keeps us from tuning a dbl over integer values   dbl_unbounded = to_tune(p_int(1, 10)),    # tune over values \"a\" and \"b\" only   fct = to_tune(c(\"a\", \"b\")),    # tune over integers 2..8.   # ParamUty needs type information in form of p_xxx() in to_tune.   uty1 = to_tune(p_int(2, 8)),    # tune uty2 like a factor, trying 1, 10, and 100:   uty2 = to_tune(c(1, 10, 100)),    # tune uty3 like a factor. The factor levels are the names of the list   # (\"exp\", \"square\"), but the trafo will generate the values from the list.   # This way you can tune an objective that has function-valued inputs.   uty3 = to_tune(list(exp = exp, square = function(x) x^2)),    # tune through multiple parameters. When doing this, the ParamSet in tune()   # must have the trafo that generates a list with one element and the right   # name:   uty4 = to_tune(ps(     base = p_dbl(0, 1),     exp = p_int(0, 3),     .extra_trafo = function(x, param_set) {       list(uty4 = x$base ^ x$exp)     }   )),    # not all values need to be tuned!   uty5 = 100 )  print(params$values) #> $int #> Tuning over: #> <entire parameter range> #>  #>  #> $int_unbounded #> Tuning over: #> range [2, 7] #>  #>  #> $dbl #> Tuning over: #> range [1, ...] (log scale) #>  #>  #> $dbl_unbounded #> Tuning over: #> p_int(lower = 1, upper = 10) #>  #> $fct #> Tuning over: #> p_fct(levels = c(\"a\", \"b\")) #>  #> $uty1 #> Tuning over: #> p_int(lower = 2, upper = 8) #>  #> $uty2 #> Tuning over: #> p_fct(levels = c(`1` = 1, `10` = 10, `100` = 100)) #>  #> $uty3 #> Tuning over: #> p_fct(levels = list(exp = .Primitive(\"exp\"), square = function(x) x^2)) #>  #> $uty4 #> Tuning over: #> <ParamSet(2)> #>        id    class lower upper nlevels        default  value #>    <char>   <char> <num> <num>   <num>         <list> <list> #> 1:   base ParamDbl     0     1     Inf <NoDefault[0]>        #> 2:    exp ParamInt     0     3       4 <NoDefault[0]>        #> Trafo is set. #>  #> $uty5 #> [1] 100 #>   print(params$search_space()) #> <ParamSet(10)> #>                id    class lower     upper nlevels        default  value #>            <char>   <char> <num>     <num>   <num>         <list> <list> #>  1:           int ParamInt     0 10.000000      11 <NoDefault[0]>        #>  2: int_unbounded ParamInt     2  7.000000       6 <NoDefault[0]>        #>  3:           dbl ParamDbl     0  2.302585     Inf <NoDefault[0]>        #>  4: dbl_unbounded ParamInt     1 10.000000      10 <NoDefault[0]>        #>  5:           fct ParamFct    NA        NA       2 <NoDefault[0]>        #>  6:          uty1 ParamInt     2  8.000000       7 <NoDefault[0]>        #>  7:          uty2 ParamFct    NA        NA       3 <NoDefault[0]>        #>  8:          uty3 ParamFct    NA        NA       2 <NoDefault[0]>        #>  9:          base ParamDbl     0  1.000000     Inf <NoDefault[0]>        #> 10:           exp ParamInt     0  3.000000       4 <NoDefault[0]>        #> Trafo is set.  # Change `$values` directly and generate new `$search_space()` to play around params$values$uty3 = 8 params$values$uty2 = to_tune(c(2, 4, 8))  print(params$search_space()) #> <ParamSet(9)> #>               id    class lower     upper nlevels        default  value #>           <char>   <char> <num>     <num>   <num>         <list> <list> #> 1:           int ParamInt     0 10.000000      11 <NoDefault[0]>        #> 2: int_unbounded ParamInt     2  7.000000       6 <NoDefault[0]>        #> 3:           dbl ParamDbl     0  2.302585     Inf <NoDefault[0]>        #> 4: dbl_unbounded ParamInt     1 10.000000      10 <NoDefault[0]>        #> 5:           fct ParamFct    NA        NA       2 <NoDefault[0]>        #> 6:          uty1 ParamInt     2  8.000000       7 <NoDefault[0]>        #> 7:          uty2 ParamFct    NA        NA       3 <NoDefault[0]>        #> 8:          base ParamDbl     0  1.000000     Inf <NoDefault[0]>        #> 9:           exp ParamInt     0  3.000000       4 <NoDefault[0]>        #> Trafo is set.  # Notice how `logscale` applies `log()` to lower and upper bound pre-trafo: params = ps(x = p_dbl())  params$values$x = to_tune(1, 100, logscale = TRUE)  print(params$search_space()) #> <ParamSet(1)> #>        id    class lower   upper nlevels        default  value #>    <char>   <char> <num>   <num>   <num>         <list> <list> #> 1:      x ParamDbl     0 4.60517     Inf <NoDefault[0]>        #> Trafo is set.  grid = generate_design_grid(params$search_space(), 3)  # The grid is equidistant within log-bounds pre-trafo: print(grid) #> <Design> with 3 rows: #>           x #>       <num> #> 1: 0.000000 #> 2: 2.302585 #> 3: 4.605170  # But the values are on a log scale scale with desired bounds after trafo: print(grid$transpose()) #> [[1]] #> [[1]]$x #> [1] 1 #>  #>  #> [[2]] #> [[2]]$x #> [1] 10 #>  #>  #> [[3]] #> [[3]]$x #> [1] 100 #>  #>"},{"path":"https://paradox.mlr-org.com/news/index.html","id":"paradox-100","dir":"Changelog","previous_headings":"","what":"paradox 1.0.0","title":"paradox 1.0.0","text":"CRAN release: 2024-06-11 ParamSet now supports extra_trafo natively; behaves like .extra_trafo ps() call. ParamSet $constraint ParamSet objects now less mutable. properties can changed values, tags, deps, constraint extra_trafo. ParamSet$is_bounded vector entry parameter. Use $all_bounded previous behavior. Condition objects now S3 objects can constructed CondEqual() CondAnyOf(), instead CondXyz$new(). (recommended use Domain interface conditions, changed) ParamSet new fields $is_logscale, $has_trafo_param (per-param), $has_trafo_param (scalar whole set). Added vignette previously chapter mlr3book feat: added support InternalTuneTokens","code":""},{"path":"https://paradox.mlr-org.com/news/index.html","id":"paradox-0111","dir":"Changelog","previous_headings":"","what":"paradox 0.11.1","title":"paradox 0.11.1","text":"CRAN release: 2023-03-17 Minor bug fixes.","code":""},{"path":"https://paradox.mlr-org.com/news/index.html","id":"paradox-0110","dir":"Changelog","previous_headings":"","what":"paradox 0.11.0","title":"paradox 0.11.0","text":"CRAN release: 2022-11-21 feat: function generate_design_sobol() generates space-filling Sobol sequence design. refactor: $set_values returns parameter set invisible.","code":""},{"path":"https://paradox.mlr-org.com/news/index.html","id":"paradox-0100","dir":"Changelog","previous_headings":"","what":"paradox 0.10.0","title":"paradox 0.10.0","text":"CRAN release: 2022-08-05 Reset .has_extra_trafo FALSE trafo set NULL. rd_info.ParamSet collapses vector \"\\n\" due changes roxygen 7.2.0 Add method set_values() conveniently add parameter values.","code":""},{"path":"https://paradox.mlr-org.com/news/index.html","id":"paradox-090","dir":"Changelog","previous_headings":"","what":"paradox 0.9.0","title":"paradox 0.9.0","text":"CRAN release: 2022-04-18 Added default_values() function extract default values ParamSet objects.","code":""},{"path":"https://paradox.mlr-org.com/news/index.html","id":"paradox-080","dir":"Changelog","previous_headings":"","what":"paradox 0.8.0","title":"paradox 0.8.0","text":"CRAN release: 2022-01-31 Parameters now new (optional) field description. Improved printing parameters documentation (#355). warning now signaled package ParamHelpers also loaded. Fixed links.","code":""},{"path":"https://paradox.mlr-org.com/news/index.html","id":"paradox-071","dir":"Changelog","previous_headings":"","what":"paradox 0.7.1","title":"paradox 0.7.1","text":"CRAN release: 2021-03-07 Sampler1D also accept ParamSets one Param now (#335). Fixed sampling zero rows Sampler1DRfun (#338). to_tune(), p_dbl(), p_int() accept logscale argument tuning logarithmic scale. to_tune can called lower upper now infer bound possible.","code":""},{"path":"https://paradox.mlr-org.com/news/index.html","id":"paradox-070","dir":"Changelog","previous_headings":"","what":"paradox 0.7.0","title":"paradox 0.7.0","text":"CRAN release: 2021-01-23 ParamSet$get_values() checks whether required parameter values set. Required parameter checked anymore new values added parameter set. ParamSet$check_dt() accepts data.frames. Rename is_numeric is_categorical all_numeric all_categorical. Rename requires depends.","code":""},{"path":"https://paradox.mlr-org.com/news/index.html","id":"paradox-060","dir":"Changelog","previous_headings":"","what":"paradox 0.6.0","title":"paradox 0.6.0","text":"CRAN release: 2020-12-04 ps() shortcuts ParamSet construction, new Domain construct constructors p_dbl, p_int, p_lgl, p_fct, p_uty. ParamSet$search_space() method constructs tunable ParamSet TuneToken objects, constructed to_tune().","code":""},{"path":"https://paradox.mlr-org.com/news/index.html","id":"paradox-050","dir":"Changelog","previous_headings":"","what":"paradox 0.5.0","title":"paradox 0.5.0","text":"CRAN release: 2020-10-21 Compact -memory representation R6 objects save space saving objects via saveRDS(), serialize() etc. Improved performance ParamSetCollection.","code":""},{"path":"https://paradox.mlr-org.com/news/index.html","id":"paradox-040","dir":"Changelog","previous_headings":"","what":"paradox 0.4.0","title":"paradox 0.4.0","text":"CRAN release: 2020-07-21 New public methods is_numeric() is_categorical() parameter sets. Fixed test upcoming release data.table(). Added helper function format parameter sets Rd files.","code":""},{"path":"https://paradox.mlr-org.com/news/index.html","id":"paradox-030","dir":"Changelog","previous_headings":"","what":"paradox 0.3.0","title":"paradox 0.3.0","text":"CRAN release: 2020-07-07 New function transpose() converts data.table parameter values list lists. New methods ParamSet$check_dt(), $assert_dt() test_dt() can check data.table valid parameter values. Documentation updated. Unified style object printers.","code":""},{"path":"https://paradox.mlr-org.com/news/index.html","id":"paradox-020","dir":"Changelog","previous_headings":"","what":"paradox 0.2.0","title":"paradox 0.2.0","text":"CRAN release: 2020-04-15 Fixed warnings partial argument matching. Enforce integer bounds ParamInt (#258). Reexport data.table::.data.table(). Deep cloning ParamSet$values (#273).","code":""},{"path":"https://paradox.mlr-org.com/news/index.html","id":"paradox-010","dir":"Changelog","previous_headings":"","what":"paradox 0.1.0","title":"paradox 0.1.0","text":"CRAN release: 2019-07-12 Initial release.","code":""}]
