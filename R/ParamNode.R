#' @title Parameter Node Object
#' @format \code{\link{R6Class}} object
#'
#' @description
#' A \code{\link[R6]{R6Class}} to represent parameters.
#' 
#' @section Member Variables:
#' 
#' \describe{
#'   \item{id}{[\code{character}] \cr Unique id.}
#'   \item{storage.type}{[\code{character(1)}] \cr How are values for this Parameter represented as an R object.}
#'   \item{check}{[\code{function}] \cr A function that returns \code{TRUE} for valid parameter values and a \code{character} if the value is not valid.}
#'   \item{assert}{[\code{function}] \cr A assertion generated by \code{\link[checkmate]{makeAssertionFunction}} from the \code{check} function.}
#'   \item{test}{[\code{function}] \cr A test generated by \code{\link[checkmate]{makeTestFunction}} from the \code{check} function.}
#'   \item{tags}{[\code{character}] \cr A vector of \code{characters} that indicate special properties of this Parameter.}
#' }
#' 
#' @section Methods:
#' 
#' \describe{
#'   \item{sample(n)}{[\code{function}] \cr Function to sample Parameter values. Always returns a \code{data.table}.}
#'   \item{denorm(x)}{[\code{function}] \cr Takes a named list. Each list item contains a numerical vector with values between \code{[0,1]}. These values will be mapped to values of the Parameter Space.}
#' }
#' 
#' @section Active Bindings:
#' 
#' \describe{
#'   \item{has.finite.bounds}{\code{logical(1)} \cr Does the Parameter have finite bounds.}
#' }
#'
#' @return [\code{\link{ParamNode}}].
#' @family ParamHelpers
ParamNode = R6Class("ParamNode",
  inherit = ParamBase,
  public = list(
   
    # member variables
    id = NULL, # string to uniquely identify this param
    handle = NULL, # additional stuff
    storage.type = NULL, # of what R data storage.type can values of this parameter be stored?
    check = NULL, # a checkmate check function to validate if a value is valid for this Param
    assert = NULL, # assertion generated from the above check
    test = NULL, # test generated from the above check
    tags = NULL, # additional properties like "on.train", "on.test" or "tunable" for mlr
    
    # constructor
    initialize = function(id, storage.type, check, handle = NULL, tags) {
      handle = handle %??% ParamHandle$new(id = id, node = self)
      assertString(id)
      self$id = assertNames(id, type = "strict")
      self$storage.type = assertString(storage.type)
      self$check = assertFunction(check)
      self$test = makeTestFunction(check)
      self$assert = makeAssertionFunction(check)
      self$handle = assertClass(handle, "ParamHandle")
      self$tags = assertCharacter(tags, null.ok = TRUE)
    },
    
    # public methods
    sample = function(n = 1L) {
      stop("sample not implemented")
    },
    denorm = function(x) {
      stop("denorm not implemented")
    }
  ),
  active = list(
    has.finite.bounds = function() NA
  )
)
