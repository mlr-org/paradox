#' @title ParamBase Object
#' @format \code{\link{R6Class}} object
#'
#' @description
#' Abstract base class \code{\link[R6]{R6Class}} to represent a parameter.
#'
#' @section Member Variables:
#'
#' \describe{
#'   \item{default}{[\code{any}] \cr
#'     default value.}
#'   \item{special_vals}{[\code{any}] \cr
#'     Special values this parameter is allowed to take that are within the defined space.}
#' }
#'
#' Inherited from \code{ParamNode}:
#' @inheritSection ParamNode Member Variables
#'
#' @section Methods:
#'
#' \describe{
#'   \item{sampleVector(n)}{[\code{function}] \cr
#'     samples \code{n} Parameter Values.}
#'   \item{denorm_vector(x)}{[\code{function}] \cr
#'     Takes a vector with values between \code{[0,1]} and maps them to values of the Parameter.}
#' }
#'
#' Inherited from \code{ParamNode}:
#' @inheritSection ParamNode Methods
#'
#' @section Active Bindings:
#'   \emph{none}
#'
#' @family ParamBase
ParamBase = R6Class("ParamBase",
  public = list(

    # member variables
    id = NULL, # string to uniquely identify this param
    storage_type = NULL, # of what R data storage_type can values of this parameter be stored?
    check = NULL, # a checkmate check function to validate if a value is valid for this Param
    assert = NULL, # assert_ion generated from the above check
    test = NULL, # test generated from the above check
    tags = NULL, # additional properties like "on_train", "on_test" or "tunable" for mlr
    default = NULL,
    special_vals = NULL, # special values as list, can not be changed after initialization

    # constructor
    initialize = function(id, storage_type, check, special_vals, default, tags) {

      if (!is.null(special_vals) && is.na(special_vals)) special_vals = list(special_vals)
      assert_list(special_vals, null.ok = TRUE)


      # set member variables
      assert_string(id)
      self$id = assert_names(id, type = "strict")
      self$storage_type = assert_string(storage_type)
      self$check = assert_function(check)
      self$test = makeTestFunction(check)
      self$assert = makeAssertionFunction(check)
      self$tags = assert_character(tags, null.ok = TRUE)
      self$default = self$assert(default, null.ok = TRUE)
      self$special_vals = special_vals
    },

    # public methods
    # Overwriting ParamNode Methods
    sample = function(n = 1L) as_dt_cols(self$sampleVector(n = n), self$id),
    denorm = function(x) as_dt_cols(self$denorm_vector(x[[self$id]]), self$id),

    # ParamBaseMethods
    sampleVector = function(n = 1L) {
      # samples vector values without respecting what is 'restriction'
      stop("sampleVector not implemented")
    },
    denorm_vector = function(x) {
      stop("denorm function not implemented!")
    },
    print = function(newline = TRUE, ...) {
      catf("%s [%s]", self$id, self$storage_type)
      if (!is.null(self$special_vals)) {
        catf("+{special_vals}") #FIXME: Better Printer for special_vals!
      }
      if (!is.null(self$default)) {
        catf(" (Default: %s)", as.character(self$default))
      }
      if (!is.null(self$tags)) {
        catf(" (Tags: %s)", paste(self$tags, collapse = ", "))
      }
      if (newline) {
        cat("\n")
      }
    },
    value_to_string = function(x, ...) {
      stop("value_to_string not implemented!")
    }
  ),

  active = list(
    dictionary = function(x) {
      if (missing(x)) {
        return(private$priv_dictionary)
      } else if (!is.null(x)) {
        x = as.environment(x)
        private$priv_dictionary = x
      }
    }
  ),
  private = list(
    priv_dictionary = NULL
  )
)
