% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Param.R
\docType{data}
\name{Param}
\alias{Param}
\alias{ParamDbl}
\alias{ParamInt}
\alias{ParamFct}
\alias{ParamLgl}
\alias{ParamUty}
\title{Param Object}
\format{\link{R6Class} object.}
\usage{
Param
}
\description{
Abstract base class for params and inheriting concrete param subclasses.
}
\section{Public members / active bindings}{

\itemize{
\item \code{id}               :: \code{character(1)} \cr
ID of this param.
\item \code{class}           :: \code{character(1)} \cr
Param R6 class name. Read-only.
\item \code{lower}            :: \code{numeric(1)} \cr
Lower bound for dbl/int params, can be -Inf. NA if param is not a number.
\item \code{upper}            :: \code{numeric(1)} \cr
Upper bound for dbl/int params, can be +Inf. NA if param is not a number.
\item \code{values}           :: \code{character} | \code{logical} | \code{NULL} \cr
Allowed values for categorical params, NULL if param is not categorical.
\item \code{nlevels}          :: \code{numeric(1)} \cr
Number of categorical levels per parameter, Inf for unbounded ints or any dbl. Read-only.
\item \code{is_bounded}       :: \code{logical(1)} \cr
Does param have a finitely bounded domain? Read-only.
\item \code{special_vals}     :: \code{list} \cr
Arbitrary special values this parameter is allowed to take, to make it feasible.
This allows extending the domain of the param.
This is only used in feasibility checks, neither in generating designs nor sampling.
\item \code{default}          :: \code{any} \cr
Default value. Can be from param domain or \code{special_vals}.
Has value \code{NO_DEF} if no default is there - \code{NULL} could be a valid default.
\item \code{has_default}      :: \code{logical(1)} \cr
Is a default there?
\item \code{storage_type}     :: \code{character(1)} \cr
Data type when values of this param is stored in a data table or sampled. Read-only.
\item \code{tags}             :: \code{character} \cr
Can be used to group and subset params.
\item is_number          :: \code{logical(1)}
TRUE iff Param is dbl or int.
\item is_categ           :: \code{logical(1)}
TRUE iff Param is fct or lgl.
}
}

\section{Public methods}{

\itemize{
\item \code{Param$new(id, special_vals = list(), default = NO_DEF, tags = character(0L))} \cr
\code{character(1)}, \code{list}, \code{any}, \code{character} -> self \cr
Constructor of abstract base class, only called by inheriting classes.
See meaning of \code{id}, \code{special_vals}, \code{default}, \code{tags} in member section.
\item \code{Param$Dbl$new(id, lower, upper, special_vals, default, tags)} \cr
\code{character(1)}, \code{numeric(1)}, \code{numeric(1)}, \code{list}, \code{any}, \code{character} -> self
Constructor for double-scalar-params. Box-constraint bounds can be set, or be Inf.
\item \code{Param$Int$new(id, lower, upper, special_vals, default, tags)} \cr
\code{character(1)}, \code{numeric(1)}, \code{numeric(1)}, \code{list}, \code{any}, \code{character} -> self
Constructor for int-scalar-params. Box-constraint bounds can be set, or be Inf;
\code{lower} is set to its integer ceiling and 'upper' to its integer floor value.
\item \code{ParamFct$new(id, values, special_vals, default, tags)} \cr
\code{character(1)}, \code{character}, \code{list}, \code{any}, \code{character} -> self
Constructor for categorical/factor-like params; slight misnomer as it accepts only strings,
from its defined set of categorical values.
\item \code{Param$Lgl$new(id, special_vals, default, tags)} \cr
\code{character(1)}, \code{list}, \code{any}, \code{character} -> self
Constructor for logical-scalar-params.
\item \code{ParamUty$new(id, default, tags, custom_check)} \cr
\code{character(1)}, \code{any}, \code{character}, \code{function(x)} -> self
Untyped parameters, can be used to bypass any complicated feasibility checks, when
a param is of truly complex type, as checks for this param are always feasible.
OTOH we cannot perform meaningful operations like sampling or generating designs with this param.
User can pass a \code{custom_check} to specify feasibility checks for custom types.
\item \code{test(x)}, \code{check(x)}, \code{assert(x)} \cr
Three checkmate-like check-functions. Take a value from the domain of the param, and check if it is feasible.
A value is feasible if it is of the same \code{storage_type}, inside of the bounds or from \code{special_vals}.
\item \code{qunif(x)} \cr
\code{numeric(n)} -> \code{vector(n)} \cr
Takes values from [0,1] and map them, regularly distributed, to the domain of the param.
Think of: quantile function or the usecse to map a uniform-[0,1] random variable into a uniform sample from this param.
\item \code{rep(n)} \cr
\code{integer(1)} -> \link{ParamSet} \cr
Repeats this param n-times (by cloning); each param is named "<id>\emph{rep}<k>" and gets additional tag "<id>_rep".
}
}

\section{Further public methods for ParamDbl, ParamInt}{

\itemize{
\item \code{range}            :: \code{numeric(2)} \cr
Lower and upper bound as 2-dim-vector.
\item \code{span}            :: \code{numeric(1)} \cr
Difference of \code{upper - lower}.
}
}

\section{S3 methods and type converters}{

\itemize{
\item \code{as.data.table()} \cr
Converts param to datatable with 1 row. See \link{ParamSet}.
}
}

\concept{Param}
\keyword{datasets}
